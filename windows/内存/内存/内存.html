<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>内存 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="full-width small-font less-lead"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="内存" class="main-title"></div></div></header><article><blockquote id="3JAemQaCxgyzd7DHRsy81t" class="wolai-block"><span class="inline-wrap">问题<span class="jill"></span>1：如何确定内存使用了大页面还是巨型页。</span></blockquote><h1 id="8XBxGmmJmpjGKxXhdGb8VP" class="wolai-block"><span class="inline-wrap">Windows 内存</span></h1><h2 id="6NwqWGmMJznhtw7PJ22UJP" class="wolai-block"><span class="inline-wrap">任务管理器指标说明</span></h2><div id="jnJdcJSRYPfVYX2tXiBRzH" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>内存使用量：</b></span><span class="inline-wrap"><b>内存使用量：</b></span><span class="inline-wrap"> 为物理内存使用量，但不包括设备的内容。12.6GB<span class="jill"></span>为内存物理总量</span><span class="inline-wrap"> 为物理内存使用量，但不包括设备的内容。12.6GB<span class="jill"></span>为内存物理总量</span></div></div><div id="axY3nAPDK9zEYrgJWF9rPr" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>使用中（已压缩）：</b></span><span class="inline-wrap"><b>使用中（已压缩）：</b></span><span class="inline-wrap"> 由进程、驱动程序或操作系统使用的物理内存</span><span class="inline-wrap"> 由进程、驱动程序或操作系统使用的物理内存</span></div></div><div id="6B9GcaLWfFChUBhZxHamar" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>可用：</b></span><span class="inline-wrap"><b>可用：</b></span><span class="inline-wrap"> 实际内存物理量，当前未使用但会在进程、驱动程序或操作系统需要更多内存时首先重新使用的内存。等于备用、可用、零页面的大小总和。</span><span class="inline-wrap"> 实际内存物理量，当前未使用但会在进程、驱动程序或操作系统需要更多内存时首先重新使用的内存。等于备用、可用、零页面的大小总和。</span></div></div><div id="oD4nnr5fH8Tg8Mrfy1tjbz" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>已提交：</b></span><span class="inline-wrap"><b>已提交：</b></span><span class="inline-wrap"> 15.1GB<span class="jill"></span>为虚拟内存的最大值，5.2GB<span class="jill"></span>为虚拟内存使用中。</span><span class="inline-wrap"> 15.1GB<span class="jill"></span>为虚拟内存的最大值，5.2GB<span class="jill"></span>为虚拟内存使用中。</span></div></div><div id="2P729xCWjPPKXnhNU8u1K5" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>已缓存：</b></span><span class="inline-wrap"><b>已缓存：</b></span><span class="inline-wrap"> 系统缓存内存量(备用列表的大小以及系统工作集综合：Cache Bytes、Modified Page List Bytes、StandBy Cache Core Bytes、Standby Cache Normal Priority Bytes、StandBy Cache Reserve Bytes<span class="jill"></span>的总和)</span><span class="inline-wrap"> 系统缓存内存量(备用列表的大小以及系统工作集综合：Cache Bytes、Modified Page List Bytes、StandBy Cache Core Bytes、Standby Cache Normal Priority Bytes、StandBy Cache Reserve Bytes<span class="jill"></span>的总和)</span></div></div><div id="aJSsfCD1cuyRfbHTV8ZMPP" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>分页缓冲池：</b></span><span class="inline-wrap"><b>分页缓冲池：</b></span><span class="inline-wrap"> 分页池的总大小，包括空闲和已分配的区域</span><span class="inline-wrap"> 分页池的总大小，包括空闲和已分配的区域</span></div></div><div id="wNhkJrS3Mey3prvBMwYbp1" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>非分页缓冲池：</b></span><span class="inline-wrap"><b>非分页缓冲池：</b></span><span class="inline-wrap"> 非分页池的总大小，包括空闲和已分配的区域</span><span class="inline-wrap"> 非分页池的总大小，包括空闲和已分配的区域</span></div></div><div id="kiyGvNXTETFRQzCpVibzQD" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>备用：</b></span><span class="inline-wrap"><b>备用：</b></span><span class="inline-wrap"> 包含未频繁使用的缓存数据和代码的内存</span><span class="inline-wrap"> 包含未频繁使用的缓存数据和代码的内存</span></div></div><h2 id="vQr6BeprVsY9EhvcPPERX8" class="wolai-block"><span class="inline-wrap">页面</span></h2><h3 id="eJL9nTQiYLijrW6eWRjpKX" class="wolai-block"><span class="inline-wrap">页面类型</span></h3><div id="q82H2b8mKv7Y1qFZaUXyvM" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>小页面：</b></span></div></div><div id="oxMR74Xn9G43vGTkgjV1rk" class="wolai-block wolai-text"><div><span class="inline-wrap">默认<span class="jill"></span>4KB</span></div></div><div id="8v5tG2dY4FsZiRPyyVoJzs" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>大页面（large gage）：</b></span></div></div><div id="sLQtRy9FCE3d4qAB4FfmGn" class="wolai-block wolai-text"><div><span class="inline-wrap">大页面<span class="jill"></span>2MB，一个大页面等于<span class="jill"></span>512<span class="jill"></span>个小页面。大页面的优势在于地址转译速度更快。</span></div></div><div id="mm3xLKoLVGHmFqpwcMEdwQ" class="wolai-block wolai-text"><div><span class="inline-wrap">在系统长时间运行后，大型页内存区域可能很难获取，因为每个大型页面的物理空间必须连续，但内存可能已碎片化。 在这些条件下分配大型页面可能会导致大页面分配失败显著影响系统性能。</span></div></div><blockquote id="sPJVDhDc6HcvB5vmbaPkCJ" class="wolai-block"><span class="inline-wrap">大页面需要处理器支持。参考</span><span class="inline-wrap"><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-getlargepageminimum"><span>GetLargePageMinimun<span class="jill"></span>函数的<span class="jill"></span>MEM_LARGE_PAGES<span class="jill"></span>标志</span></a></span><span class="inline-wrap">
</span><span class="inline-wrap">设置大页面内存，参考</span><span class="inline-wrap"><a href="https://learn.microsoft.com/zh-cn/windows/win32/memory/large-page-support"><span>Large-Page<span class="jill"></span>支持</span></a></span></blockquote><div id="r2UNgqUFYYBPuYSeYsQMUR" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>巨型页（huge page）：</b></span></div></div><div id="kaM29Pd1p6ciXSkZgPa1FZ" class="wolai-block wolai-text"><div><span class="inline-wrap">巨型页可达<span class="jill"></span>1GB，如果分配的请求大小超过<span class="jill"></span>1GB，自动分配巨型页。</span></div></div><h3 id="6VnoXkTbYNvkLARGpPaa7b" class="wolai-block"><span class="inline-wrap">页面状态</span></h3><div id="77FyVLAZ16RXA9YV3nMhXo" class="wolai-block wolai-text"><div><span class="inline-wrap">页面是</span><span class="inline-wrap"><b>空闲的（free）</b></span><span class="inline-wrap">、</span><span class="inline-wrap"><b>保留的（reserved）</b></span><span class="inline-wrap">、</span><span class="inline-wrap"><b>提交的（committed）</b></span><span class="inline-wrap">、或是</span><span class="inline-wrap"><b>共享的（shareable）</b></span><span class="inline-wrap">。</span></div></div><div id="1sJcKQ3awikiD9HKP1L5Qn" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>共享的页面：</b></span><span class="inline-wrap"><b>共享的页面：</b></span><span class="inline-wrap"> 他们在被访问时，最终会被转移到物理内存的有效页面。并且是其他进程共有的。</span><span class="inline-wrap"> 他们在被访问时，最终会被转移到物理内存的有效页面。并且是其他进程共有的。</span></div></div><div id="xAM5xU8Egiuq7LjnVGDnbK" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>提交的页面：</b></span><span class="inline-wrap"><b>提交的页面：</b></span><span class="inline-wrap"> 是进程私有的页面，首次访问时以零初始化页面的方式创建出来。</span><span class="inline-wrap"> 是进程私有的页面，首次访问时以零初始化页面的方式创建出来。</span></div></div><div id="mVrte8gMRu9C5nysJx1KLU" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>保留的页面：</b></span><span class="inline-wrap"><b>保留的页面：</b></span><span class="inline-wrap"> 设置一段连续的虚拟地址以供日后使用，并只占一丢丢丢资源，等待真正需要使用时再提交。。试图访问这部分内存将导致异常。</span><span class="inline-wrap"> 设置一段连续的虚拟地址以供日后使用，并只占一丢丢丢资源，等待真正需要使用时再提交。。试图访问这部分内存将导致异常。</span></div></div><ol class="wolai-block"><li id="fEj185WerDxAfXSRr4nbZk"><div class="marker"></div><span class="inline-wrap">ReadProcessMemory<span class="jill"></span>函数和<span class="jill"></span>WriteProcessMemory<span class="jill"></span>函数允许跨进程访问。他们需要满足俩者之一的条件，目标进程的安全描述符被授予<span class="jill"></span>PROCESS_VM_READ<span class="jill"></span>或<span class="jill"></span>PROCESS_VM_WRITE<span class="jill"></span>权限，或者拥有<span class="jill"></span>SeDebugPrivilege<span class="jill"></span>特权，它默认值授予<span class="jill"></span>Administrators<span class="jill"></span>组的成员。</span></li><li id="rQQkrgHfWhdE54HWAJ4ZXt"><div class="marker"></div><span class="inline-wrap">解除提交后的内存依然是被保留的，释放内存是空闲的、自由的。</span></li></ol><h2 id="4TECEHP9gcqN8SceFGxijR" class="wolai-block"><span class="inline-wrap">内核模式的换页池和非换页池</span></h2><div id="86kAaYoSypZbAmY3qyZMaW" class="wolai-block wolai-text"><div><span class="inline-wrap">对于非换页池和换页池都位于系统地址空间，可以映射到每个进程的虚拟地址空间。</span></div></div><div id="vL8548sZzorEUvu5zQMumd" class="wolai-block wolai-text"><div><span class="inline-wrap">非换页池：</span></div></div><div id="vhZpXETfXJ4T6y5U2iaa2q" class="wolai-block wolai-text"><div><span class="inline-wrap">在任何时间总是驻留在物理内存中的虚拟地址组成，不产生任何页面错误。</span></div></div><blockquote id="5EwdkFUNiYBJDjrQSEtmBx" class="wolai-block"><span class="inline-wrap">意义：可以从任何<span class="jill"></span>IRQL<span class="jill"></span>访问</span><span class="inline-wrap">
</span><span class="inline-wrap">必要性：任何代码和数据如果需要在</span><span class="inline-wrap"><a href="https://zh.wikipedia.org/wiki/延迟过程调用"><span>DPC</span></a></span><span class="inline-wrap">/dispatch<span class="jill"></span>级别或更高级别上执行或访问，都必须位于非换页内存池中，因为在此级别中页面错误无法被满足</span></blockquote><div id="d8suBNNn2Zn532CPdf8yeQ" class="wolai-block wolai-text"><div><span class="inline-wrap">换页池：</span></div></div><div id="iCsJAfdpS7PPhM59YCmbkD" class="wolai-block wolai-text"><div><span class="inline-wrap">可以换入或换出系统。换页池可以从任何进程访问。</span></div></div><blockquote id="3huMcsFrHyunR8r6vehdS8" class="wolai-block"><span class="inline-wrap">如果设备驱动程序无需从</span><span class="inline-wrap"><a href="https://zh.wikipedia.org/wiki/延迟过程调用"><span>DPC</span></a></span><span class="inline-wrap">/dispatch<span class="jill"></span>级别或更高级别上执行或访问，即可使用换页池</span></blockquote><h2 id="utEZ2k81ch46jWnG4taBMW" class="wolai-block"><span class="inline-wrap">堆</span></h2><div id="c5ejCkUrzJzv6y5NgdfBip" class="wolai-block wolai-text"><div><span class="inline-wrap">Windows10 有俩种堆，一种是<span class="jill"></span>NT<span class="jill"></span>堆，一种是段堆（被<span class="jill"></span>UWP<span class="jill"></span>应用和某些系统进程使用）。用户模式的<span class="jill"></span>NT<span class="jill"></span>堆由堆前端和堆后端组成，其中堆后端包括堆的基本功能：段内部内存块管理、段管理、堆扩展策略、内存提交和内存接触以及大块管理。</span></div></div><h2 id="68fveog1rqnuyqPb6gVUcb" class="wolai-block"><span class="inline-wrap">虚拟内存</span></h2><div id="o8YtLGVpNUZzWGDZbxt6dF" class="wolai-block wolai-text"><div><span class="inline-wrap">Windows<span class="jill"></span>进程运行于私有的空间地址，该空间地址是线性的，并映射于物理内存（内存管理器作用<span class="jill"></span>1）上，因此该空间叫做虚拟内存。</span></div></div><div id="xp3dueVdVuP49S8bRRP8fd" class="wolai-block wolai-text"><div><span class="inline-wrap">当进程需要用到更多的内存（超过物理内存）时，内存管理器（ntoskrnl.exe）会将内存的部分内容或者翻（英文动词：page）到磁盘中。于是就可以释放这部分物理内存。当进程需要访问已经被放到硬盘中的内存时，内存管理器会将这部分信息放回内存中（内存管理器作用<span class="jill"></span>2）。在硬件的支持下，应用程序无需额外操作和内存管理器无需进程协助。</span></div></div><blockquote id="hVneYhc9jVCuHLvvGuSCg2" class="wolai-block"><span class="inline-wrap">在系统属性（sysdm.cpl）中，能够设置虚拟内存（页面文件）。但页面文件是虚拟内存的一个方面，即使不使用页面文件，也仍然使用虚拟内存。</span><span class="inline-wrap">
</span><span class="inline-wrap">获取方法-cmd</span><span class="inline-wrap">
</span><span class="inline-wrap">Systeminfo</span></blockquote><div id="qw4zWWVtgVh4UGR97y4aev" class="wolai-block wolai-text"><div><span class="inline-wrap">虚拟地址空间以页面为单位，</span></div></div><blockquote id="g1NjtWhPT4XCR9HStSKgAn" class="wolai-block"><span class="inline-wrap">进程默认是<span class="jill"></span>4KB<span class="jill"></span>的，最大的虚拟地址空间不仅取决于系统版本，还取决于进程的体系结构。32<span class="jill"></span>位的程序默认<span class="jill"></span>2G，64<span class="jill"></span>位默认<span class="jill"></span>128TB。因此当进程所需的内存超过<span class="jill"></span>2G<span class="jill"></span>时，应该编译位<span class="jill"></span>64<span class="jill"></span>位，以此减少内核虚拟分配机制管理系统地址空间的成本。</span><span class="inline-wrap">
</span><span class="inline-wrap">64<span class="jill"></span>位的地址最高访问<span class="jill"></span>16EB<span class="jill"></span>的虚拟空间，但由于<span class="jill"></span>CPU<span class="jill"></span>和系统内核的限制，目前只实现到<span class="jill"></span>128TB。</span></blockquote><div id="qDgxtavCD62ViW2yZeXKqU" class="wolai-block wolai-text"><div><span class="inline-wrap">虚拟地址空间中的提交量：表示系统中所有虚拟内存的总量</span></div></div><div id="86PcRjxaiCLJgFeUF98gZS" class="wolai-block wolai-text"><div><span class="inline-wrap">虚拟地址空间的基本布局结构:</span></div></div><div id="oJg1j7YnLDdjfpooVW37pc" class="wolai-block wolai-text"><div><span class="inline-wrap">虚拟地址有三个类型的数据被映射到此空间，分别是每个进程和会话空间、系统空间的代码和数据。</span></div></div><div id="or1R9hLtraEwBv85fPbAX8" class="wolai-block wolai-text"><div><span class="inline-wrap">进程：每个进程都有一个私有的地址空间。存储虚拟地址空间的信息是页表（page table），每个进程均有页表集合，只有从内核模式才能反问，用户模式的线程无法修改。</span></div></div><blockquote id="uQJ46TL8V5CQBxUXbFMMRt" class="wolai-block"><span class="inline-wrap">进程不允许访问私有地址以外的虚拟地址。共享内存是通过进程内的地址来访问，跨进程内存函数是有进程的内核模式代码来操作的。</span></blockquote><div id="wnhHv71VgiEDsLGqncsfca" class="wolai-block wolai-text"><div><span class="inline-wrap">会话空间：针对会话的全局信息。会话有进程和系统对象组成，代表了用户的一个登录会话。每个会话都有一个专门的换页池区域。当进程被创建的时候，这一地址范围被映射到进程所属会话的页面上。</span></div></div><div id="w5frNssnh15nASqjaqqm58" class="wolai-block wolai-text"><div><span class="inline-wrap">系统空间：包含了全局的操作系统代码和数据结构。他们对于所有的进程都是可见的。由系统代码、非换页内存池、换页内存池、系统缓存、系统页表项（PTE）、系统工作集列表、系统映射的视图、超空间、崩溃转储信息、HAL<span class="jill"></span>构成。</span></div></div><blockquote id="7BdfX92GC9DhnPJpJM78tC" class="wolai-block"><span class="inline-wrap">系统页表项可以由性能工具检查“Memory: Free System Page Table Entries”值得到，或由调试器使用</span><span class="inline-wrap"><code>!sysptes</code></span><span class="inline-wrap">或</span><span class="inline-wrap"><code>!vm</code></span><span class="inline-wrap">,或转储</span><span class="inline-wrap"><code>_MI_SYSTEM_PTE_TYPE</code></span><span class="inline-wrap">来得到</span></blockquote><div id="9hNbB76d4ZSu6jAyp9rXyM" class="wolai-block wolai-text"><div><span class="inline-wrap">配额：系统配额位于:计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management</span></div></div><div id="oAADDERfdnYqucN5hkAaZx" class="wolai-block wolai-text"><div><span class="inline-wrap">用户地址空间的布局结构：内核地址是动态的，用户地址空间也是动态构建的。线程栈、进程堆和已加载镜像的地址都是已通过地址空间布局随机化（ASLR）的机制来动态计算的。</span></div></div><div id="1VirBCXh18qvmSVeZuC8AZ" class="wolai-block wolai-text"><div><span class="inline-wrap">一个进程所使用的虚拟内存的详细视图包括：映像，私有，可分享，映射文件，堆，栈，系统组成</span></div></div><h2 id="8HTu2rfycCqtx5s1RCn1ec" class="wolai-block"><span class="inline-wrap">堆管理器</span></h2><div id="1aNQ6N54VUyhqm3Xv2Uskg" class="wolai-block wolai-text"><div><span class="inline-wrap">进程虽然可以利用页面来分配内存块，但即使是最小的页面也是<span class="jill"></span>4KB，日常程序中对于变量可能才几十字节。因此为了满足这种需求<span class="jill"></span>Windows<span class="jill"></span>提供了堆管理器（Ntdll.dll<span class="jill"></span>和<span class="jill"></span>ntoskrnl.exe）来负责大内存区域中的内存分配。</span></div></div><blockquote id="jggPU4gin1EYrqM5SqB2x1" class="wolai-block"><span class="inline-wrap">当使用<span class="jill"></span>C<span class="jill"></span>语言的<span class="jill"></span>malloc、free<span class="jill"></span>以及<span class="jill"></span>C++<span class="jill"></span>的<span class="jill"></span>new<span class="jill"></span>是，C<span class="jill"></span>运行时（CRT）也支持堆管理器。最常用的<span class="jill"></span>Windows<span class="jill"></span>对函数如<span class="jill"></span>HeapCreate<span class="jill"></span>或<span class="jill"></span>HeanDestory、HeapAlloc<span class="jill"></span>和<span class="jill"></span>HeapFree<span class="jill"></span>等函数</span></blockquote><div id="arCMy3LuyMzG9GqECBokYZ" class="wolai-block wolai-text"><div><span class="inline-wrap">每个应用程序至少有一个堆：默认的进程堆。该堆在进程的生命周期过程中永远不会删除，默认大小<span class="jill"></span>1MB。通过<span class="jill"></span>GetProcessHeap<span class="jill"></span>函数来获得默认堆。每个进程中包含了一个数组，数组中包含了所有堆信息，利用<span class="jill"></span>GetProcessHeaps<span class="jill"></span>可以获得。</span></div></div><div id="htyUwPh2zgeqZxV7G48hGK" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>结构：</b></span></div></div><div id="iSJ4oGQbigmE9jFvojKZoz" class="wolai-block wolai-text"><div><span class="inline-wrap">应用程序为了访问内存，首先访问的是堆管理器（从<span class="jill"></span>API<span class="jill"></span>到前段堆层（可选）与核心堆层），其次有堆管理器访问内存管理器。</span></div></div><div id="9wAEDuUL3jNt7hNMhrZCfK" class="wolai-block wolai-text"><div><span class="inline-wrap">前端堆层：事可选且进针对用户模式的堆。Windows<span class="jill"></span>支持的唯一一种前段堆层是低碎片堆（LFH，Low Fragmentation Heap）。</span></div></div><div id="5dVRuaW33nHNRzknLVvK6L" class="wolai-block wolai-text"><div><span class="inline-wrap">核心堆层：最常见功能为跨用户模式和内核模式的堆实现，核心功能：段内部的内存块管理、段管理、堆的扩展策略、提交内存和解除提交、大块管理。</span></div></div><div id="gRaiushgtJX8TLQpxf2mrT" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>堆同步：</b></span></div></div><div id="3AB9TLsUGGWNra43Mjpf7L" class="wolai-block wolai-text"><div><span class="inline-wrap">堆管理器支持多个线程并发访问。当堆同步被打开时，每个堆都有一个锁，用来保护堆结构。</span></div></div><div id="1gHjg7yTGuUsG1pqwAk1bN" class="wolai-block wolai-text"><div><span class="inline-wrap">当进程是单线程时，可以在创建堆或者每次分配内存是指定<span class="jill"></span>HEAP_NO_SERIALIZE<span class="jill"></span>来告知堆管理器，避免同步开销</span></div></div><div id="gkhMVQRzHQb4BhVsgxaoKM" class="wolai-block wolai-text"><div><span class="inline-wrap">当进程是多线程时，要保持一致性状态操作，需要锁住堆。</span></div></div><h2 id="audcEkmM6SDDYzUCZqkQUy" class="wolai-block"><span class="inline-wrap">地址转义</span></h2><div id="3NfFknu1cUPJkpNsCDbpZS" class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>将虚拟地址通过页表（PT）转为物理地址。每个虚拟空间的页面都跟系统空间的结构联系在一起，该结构成为页表项（PTE）。</span></div></div><h2 id="6pxJip14fS2KwJSZ4JXumR" class="wolai-block"><span class="inline-wrap">页面文件</span></h2><div id="6o5nsFf7jANLp4QwgpWcJK" class="wolai-block wolai-text"><div><span class="inline-wrap">windows<span class="jill"></span>的页面文件是存于已经被修改，虽然被使用但不得不写到硬盘（取消了映射或处于内存压力而被袖箭）上的文件。页面文件包含了进程虚拟内存和内核虚拟内存。</span></div></div><blockquote id="tsQo2MdmVcvSqFSDLMhFH9" class="wolai-block"><span class="inline-wrap">为了安全起见，系统应该配置为当系统停机的时候清除页面文件内容,否则有人能够从物理该机器的话，就能读取数据，方法：在<span class="jill"></span>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management<span class="jill"></span>项中设置<span class="jill"></span>ClearPageFileAtShutdown=1</span></blockquote><blockquote id="kKuVWCmjDWmn72RD4qpVbQ" class="wolai-block"><span class="inline-wrap">参考：</span><span class="inline-wrap">
</span><span class="inline-wrap">内存管理：</span><span class="inline-wrap"><a href="https://learn.microsoft.com/zh-cn/windows/win32/memory/memory-management"><span>https://learn.microsoft.com/zh-cn/windows/win32/memory/memory-management</span></a></span><span class="inline-wrap">
</span><span class="inline-wrap">深入解析<span class="jill"></span>Windows<span class="jill"></span>第七版第一卷：</span><span class="inline-wrap"><a href="https://www.epubit.com/bookDetails?id=UBbf572b9969ab&amp;typeName"><span>https://www.epubit.com/bookDetails?id=UBbf572b9969ab&amp;typeName</span></a></span></blockquote><div id="ecExTyN8R2yLxX1pnttyFz" class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.wolai.com/25rK2ixqL3LA5D5sy57XZM"><span>保留页面和提交页面的对比实验</span></a></span></div></div></article><footer></footer></body></html>