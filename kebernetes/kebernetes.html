<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>kebernetes - wolai 笔记</title><link rel="shortcut icon" href="media/k8s_1.svg"></link></head><body class="full-width small-font less-lead"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon icon-image" style="background-image: url(&quot;media/k8s.svg&quot;)"></div></div><div data-title="kebernetes" class="main-title"></div></div></header><article><div id="p4kXKHFhkSwBmntB1GyyeH" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E5%AE%89%E8%A3%85/%E5%AE%89%E8%A3%85.html"><span>安装</span></a></div><div id="mjQatAg1DrWt14q6JP4yQb" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4/%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4.html"><span>历史命令</span></a></div><div id="35CqJf3fBUMQc7ftLQTw6u" class="wolai-row"><div id="hgJyzQTQszq3nXDtjdmGqR" class="wolai-col" style="flex-grow: 0.5"><div id="baqfkHAb4UKJFJ6hxkcWq3" class="bg-lightpink wolai-block wolai-text"><div><span class="inline-wrap">概念</span></div></div><div id="nwRafYzAPXe49uHosBMkDM" class="wolai-block wolai-text"><div><span class="blue inline-wrap">属性：</span><span class="inline-wrap">应用编排器</span></div></div><div id="ng5iRXQEb7FYwB1qkdmbn3" class="wolai-block wolai-text"><div><span class="blue inline-wrap">作用：</span><span class="inline-wrap">用于对容器化的云原生微服务应用进行编排</span></div></div><details id="5fEnbfP1i4FKvDtAVbopUf" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">工作模式</span></summary><details id="k7YS3abUHQetFgn2YnKnPe" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">应用打包</span></summary><div id="gW1mJqBfEkhDMcVYEsDpFe" class="wolai-block wolai-text"><div><span class="inline-wrap">将应用按容器方式进行打包。</span></div></div><div id="cteJiFCVpLQxaxvMfgbEeC" class="wolai-block wolai-text"><div><span class="inline-wrap">将应用封装到<span class="jill"></span>Pod<span class="jill"></span>中</span></div></div><div id="mbwyWwttx9hdFFzKuDQZ5a" class="wolai-block wolai-text"><div><span class="inline-wrap">通过声明式<span class="jill"></span>manifest<span class="jill"></span>文件部署</span></div></div><div id="p69A9F2pEKsWbaXGXe8E4V" class="wolai-block wolai-text"><div><span class="inline-wrap">使用更高层面的控制面板将<span class="jill"></span>Pod<span class="jill"></span>在集群中部署，例如<span class="jill"></span>Deployment、DaemonSet、StatefulSet、CronJob<span class="jill"></span>等。</span></div></div></details><details id="96W9sFyBz5c3TkJ1PsWGpt" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">编排器</span></summary><div id="8uFJhnuR4aMXDNKkjLV9Cg" class="wolai-block wolai-text"><div><span class="blue inline-wrap">定义</span><span class="inline-wrap">：是一套部署和管理应用程序的系统</span></div></div><div id="4jdB15SPaog8WLHuCuc2Ax" class="wolai-block wolai-text"><div><span class="blue inline-wrap">作用</span><span class="inline-wrap">：能够部署应用，并动态响应变化。</span></div></div><details id="xdcf3GWe1H7ZiXGruiwnrr" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">具体功能</span></summary><div id="7fYKVZ4EAjKmCDHn9LHbhx" class="wolai-block wolai-text"><div><span class="inline-wrap">部署应用程序</span></div></div><div id="ov9bxoYdCmTsuckoi8SBDz" class="wolai-block wolai-text"><div><span class="inline-wrap">根据需要动态扩缩容</span></div></div><div id="2FPMcuAwyK3MJpAZFNNn87" class="wolai-block wolai-text"><div><span class="inline-wrap">当出现故障时自愈</span></div></div><div id="a63hwWU2RQwAR8Boj3PAgm" class="wolai-block wolai-text"><div><span class="inline-wrap">进行不停机的滚动升级和回滚</span></div></div></details></details><details id="2kfEkhdxhhDXopCp9xt9BE" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">声明式模型</span></summary><details id="q9tPHtE6QsBJZSWxgKu6rp" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">工作方式</span></summary><div id="iZHFz4VDegbfhYManeiFjR" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>manifest<span class="jill"></span>文件中声明一个应用（微服务）期望达到的状态。</span></div></div><div id="uHFYs3hEcJKDybSeeo3wa1" class="wolai-block wolai-text"><div><span class="inline-wrap">将<span class="jill"></span>manifest<span class="jill"></span>文件发送到<span class="jill"></span>API Server。</span></div></div><div id="6ofsgeUHYTTm2bZjByxcgq" class="wolai-block wolai-text"><div><span class="inline-wrap">Kubernetes<span class="jill"></span>将<span class="jill"></span>manifest<span class="jill"></span>存储到集群存储，并作为应用的期望状态。</span></div></div><div id="8XENPfPSRkHTPukLe4F3yg" class="wolai-block wolai-text"><div><span class="inline-wrap">Kubernetes<span class="jill"></span>在集群中实现上述期望状态。</span></div></div><div id="cuoMAcFif7eMeZMy5qWmkg" class="wolai-block wolai-text"><div><span class="inline-wrap">Kubernetes<span class="jill"></span>启动监控循环，保证应用的当前状态（current state）不会与期望状态出现差异。</span></div></div></details><details id="3Y1S3PVwHdXFVYiydAEpP1" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">具体过程</span></summary><div id="pqafCv4NaWFZjRTUVFsmzy" class="wolai-block wolai-text"><div><span class="inline-wrap">manifest<span class="jill"></span>文件是按照简版<span class="jill"></span>YAML<span class="jill"></span>格式进行编写的，用户通过<span class="jill"></span>manifest<span class="jill"></span>文件来告知<span class="jill"></span>Kubernetes<span class="jill"></span>集群自己希望应用运行的样子。这就是所谓的期望状态。其中包括：需要使用哪个镜像、有多少副本需要运行、哪个网络端口需要监听，以及如何执行更新。</span></div><div id="eHv17V9mSN6jK9WUUeYo9A" class="wolai-block wolai-text"><div><span class="inline-wrap">在用户创建了<span class="jill"></span>manifest<span class="jill"></span>文件之后，需要将其发送到<span class="jill"></span>API Server。最常见的方式是通过<span class="jill"></span>kubectl<span class="jill"></span>命令行工具来完成这个操作。kubectl<span class="jill"></span>会将<span class="jill"></span>manifest<span class="jill"></span>文件通过<span class="jill"></span>HTTP POST<span class="jill"></span>请求发送到控制平面，通常<span class="jill"></span>HTTP<span class="jill"></span>服务使用的端口是<span class="jill"></span>443。</span></div></div><div id="6r33wsarUH7n5548u3zeq3" class="wolai-block wolai-text"><div><span class="inline-wrap">在请求经过认证以及授权后，Kubernetes<span class="jill"></span>会检查<span class="jill"></span>manifest<span class="jill"></span>文件，确定需要将该文件发送到哪个控制器（例如<span class="jill"></span>Deployment controller），并将其保存到集群存储当中，作为整个集群的期望状态（desired state）中的一部分。在上述工作都完成之后，就要在集群中执行相应的调度工作了。调度工作包括拉取镜像、启动容器、构建网络以及启动应用进程。</span></div></div><div id="pHZ9kaScat125paFLBvsQZ" class="wolai-block wolai-text"><div><span class="inline-wrap">最终，Kubernetes<span class="jill"></span>通过后台的<span class="jill"></span>reconciliation（调谐）循环来持续监控集群状态。如果集群当前状态（current state）与期望状态（desired state）存在差异，则<span class="jill"></span>Kubernetes<span class="jill"></span>会执行必要的任务来解决对应的”</span></div></div></div></details></details><div id="oaUu6839hzo9qgxWXiiwbX" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details id="mgnKierja5Qww2pVf5N9ti" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">结构</span></summary><details id="s8CWFgJSwKrekdNx5D9RpT" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">组件</span></summary><details id="5RpEwrucyaemJYaVhAoPF1" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">Pod</span></summary><div id="T8Uwd6zaBzL84ommVxJHP" class="wolai-block wolai-text"><div><span class="blue inline-wrap">来源：</span><span class="inline-wrap">在英语中，会将<span class="jill"></span>a group of whales（一群鲸鱼）称作<span class="jill"></span>a Pod of whales，Pod<span class="jill"></span>就是来源于此。因为<span class="jill"></span>Docker<span class="jill"></span>的<span class="jill"></span>Logo<span class="jill"></span>是鲸鱼，所以在<span class="jill"></span>Kubernetes<span class="jill"></span>中会将包含了一组容器的事物称作<span class="jill"></span>Pod。</span></div></div><div id="xq6jimsXdT3utyNkTbuQjm" class="wolai-block wolai-text"><div><span class="blue inline-wrap">定义：</span><span class="inline-wrap">Pod<span class="jill"></span>是一个用于运行容器的有限制的环境。</span></div></div><div id="9jBbvPz4b8cyZfbp7HYdE5" class="wolai-block wolai-text"><div><span class="blue inline-wrap">描述：</span><span class="inline-wrap">Pod<span class="jill"></span>本身并不会运行任何东西，只是作为一个承载容器的沙箱而存在。换一种说法，Pod<span class="jill"></span>就是为用户在宿主机操作系统中划出有限的一部分特定区域，构建一个网络栈，创建一组内核命名空间，并且在其中运行一个或者多个容器，这就是<span class="jill"></span>Pod。</span></div></div><details id="wusVuUBcMk6qjgACPdXp1Q" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">多容器</span></summary><div id="oaUdu8dqM4y2pst7cp9zUj" class="wolai-block wolai-text"><div><span class="blue inline-wrap">描述：</span><span class="inline-wrap">共享相同的<span class="jill"></span>Pod<span class="jill"></span>环境的。共享环境中包括了<span class="jill"></span>IPC<span class="jill"></span>命名空间，共享的内存，共享的磁盘、网络以及其他资源等。</span></div></div><div id="rRghHNvEakWmYrZzkFTCc3" class="wolai-block wolai-text"><div><span class="blue inline-wrap">通信：</span><span class="inline-wrap">相同<span class="jill"></span>pod<span class="jill"></span>中，使用<span class="jill"></span>Pod<span class="jill"></span>提供的<span class="jill"></span>localhost<span class="jill"></span>接口来完成。</span></div></div></details></details><details id="vk5PB9EAgsRY2KEqEEmqpo" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">Service（服务）</span></summary><div id="em4TgAYcVyfgSqeEjHbY5a" class="wolai-block wolai-text"><div><span class="blue inline-wrap">职责：</span><span class="inline-wrap">一个稳定的网络终端，提供了基组动态<span class="jill"></span>Pod<span class="jill"></span>集合的<span class="jill"></span>TCP<span class="jill"></span>以及<span class="jill"></span>UDP<span class="jill"></span>负载均衡能力。</span></div></div><div id="gty76WRfWuKcYPFhrTUG34" class="wolai-block wolai-text"><div><span class="blue inline-wrap">作用：</span><span class="inline-wrap">为一组<span class="jill"></span>Pod<span class="jill"></span>提供了可靠且稳定的网络。Service<span class="jill"></span>也实现了自我监控机制，可以自动更新，并持续提供稳定的网络终端。</span></div></div><div id="reh2jmXcAubeoKWZMEHJ5B" class="wolai-block wolai-text"><div><span class="blue inline-wrap">描述：</span><span class="inline-wrap">Service<span class="jill"></span>作用于<span class="jill"></span>TCP<span class="jill"></span>以及<span class="jill"></span>UDP<span class="jill"></span>层，所以<span class="jill"></span>Service<span class="jill"></span>层并不具备应用层的智能，即无法提供应用层的主机与路径路由能力。因此，用户需要一个入口来解析<span class="jill"></span>HTTP<span class="jill"></span>请求并提供基于主机与路径的路由能力。</span></div></div><div id="ki4t6mcvJjKESUEcnJDN3H" class="wolai-block wolai-text"><div><span class="inline-wrap">负载均衡方法：通过标签和标签选择器</span></div></div><div id="eic7pxrLfa36ipCnT5o6h8" class="wolai-block"><figure class="wolai-left" style="width: 100%; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div></details><details id="7kYtu7VG5bGSzwUBUfXbC5" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">ipvs</span></summary><div id="5U43g5PfGtc2uyo2c1GPVx" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>Kubernetes（K8s）中，IPVS（IP Virtual Server）是一种高级网络负载均衡技术，用于管理集群中的服务发现和流量路由。它是一种内核级别的负载均衡技术，通过重写数据包的目标<span class="jill"></span>IP<span class="jill"></span>地址和端口来进行流量转发，从而实现高性能的负载均衡。</span></div></div><div id="vFTfRmN9CHLE9cDJaJEVL3" class="wolai-block wolai-text"><div><span class="inline-wrap">IPVS<span class="jill"></span>在<span class="jill"></span>K8s<span class="jill"></span>中的主要作用包括：</span></div></div><ol class="wolai-block"><li id="mDQxV38B7uzNbnN4egW7b2"><div class="marker"></div><span class="inline-wrap">服务发现：IPVS<span class="jill"></span>通过监视<span class="jill"></span>K8s<span class="jill"></span>集群中<span class="jill"></span>Service<span class="jill"></span>和<span class="jill"></span>Endpoints<span class="jill"></span>的变化，自动更新负载均衡规则，使得集群中的所有节点能够动态地发现和路由到服务的实际后端<span class="jill"></span>Pod。</span></li><li id="f7uV2PzufRQT2hfeNi4Hj9"><div class="marker"></div><span class="inline-wrap">负载均衡：IPVS<span class="jill"></span>根据一定的负载均衡算法（如轮询、最小连接数等）将到达<span class="jill"></span>Service<span class="jill"></span>的请求流量分发到后端的<span class="jill"></span>Pod<span class="jill"></span>实例上，从而实现请求的均衡分配。这可以确保每个<span class="jill"></span>Pod<span class="jill"></span>都能够平均地处理请求，提高整个系统的性能和可靠性。</span></li><li id="uB8tS7rZsoHw9XGmmDRZXC"><div class="marker"></div><span class="inline-wrap">高性能：相比其他负载均衡技术（如<span class="jill"></span>iptables），IPVS<span class="jill"></span>是在内核层面实现的，具有更高的性能和更低的延迟。它可以处理大量的并发连接，并且能够快速地适应集群中的变化，提供高效的负载均衡服务。</span></li><li id="wFYbVEvafk99npF1kEJ5Vs"><div class="marker"></div><span class="inline-wrap">会话保持：IPVS<span class="jill"></span>支持基于会话的负载均衡，可以确保同一客户端的请求都被路由到同一个后端<span class="jill"></span>Pod<span class="jill"></span>实例上。这对于某些应用程序来说是必需的，例如需要保持会话状态或需要与特定的后端实例进行通信的应用程序。</span></li></ol><div id="wtmbuYPKcAdtsa7PYunBWR" class="wolai-block wolai-text"><div><span class="inline-wrap">总的来说，IPVS<span class="jill"></span>在<span class="jill"></span>Kubernetes<span class="jill"></span>中扮演着重要的角色，它提供了高性能的负载均衡功能和服务发现机制，帮助管理和分发集群中的流量，实现可靠和高效的应用程序部署。</span></div></div></details><details id="br9pVetc2wMMwsRMGtKp9g" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">cgroup<span class="jill"></span>与<span class="jill"></span>systemd</span></summary><blockquote id="9pajEzZWVtXMk5MzFMQNfp" class="wolai-block"><span class="inline-wrap">当选择 systemd 作为 Linux 发行版的 init 系统时，init 进程会生成并使用根控制组 (cgroup)，并充当 cgroup 管理器。
systemd 与 cgroup 紧密集成，并为每个 systemd 单元分配一个 cgroup。 因此，如果您使用 systemd 作为带有 cgroupfs 驱动程序的 init 系统，系统将获得两个不同的 cgroup 管理器。
两个 cgroup 管理器会产生系统中可用资源和正在使用的资源的两个视图。 在某些情况下，配置为对 kubelet 和容器运行时使用 cgroupfs 但对其余进程使用 systemd 的节点在资源压力下会变得不稳定。
缓解这种不稳定性的方法是，当 systemd 是选定的 init 系统时，使用 systemd 作为 kubelet 和容器运行时的 cgroup 驱动程序。
参考页面：</span><span class="inline-wrap"><a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/#systemd-cgroup-driver"><span>https://kubernetes.io/docs/setup/production-environment/container-runtimes/#systemd-cgroup-driver</span></a></span></blockquote></details><details id="vFEVcEWzg8hpj9dczev1iP" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">Flannel</span></summary><aside id="xy5ss9R2CZpUBLJvey5UR3" class="bg-cultured wolai-block"><div data-symbol="📌" class="icon"></div><span class="inline-wrap">Flannel 是 Kubernetes 中常用的网络插件，它提供了简单、可靠、可扩展的网络解决方案，使 Kubernetes 集群中的容器能够相互通信以及与外部网络通信。</span></aside><div id="jxhnQD3HCQLbswRcmkjHXS" class="wolai-block wolai-text"><div><span class="blue inline-wrap">定义：</span><span class="inline-wrap">Flannel 是 Kubernetes 中常用的网络插件</span></div></div><div id="dYjBXmCAF4P3pbMPYz8Jji" class="wolai-block wolai-text"><div><span class="blue inline-wrap">作用：</span><span class="inline-wrap">它提供了一种简单、可靠、可扩展的网络解决方案，使 Kubernetes 集群中的容器能够相互通信以及与外部网络通信。Flannel 主要负责在 Kubernetes 集群中创建和管理一个覆盖网络，该覆盖网络将集群中的所有节点连接起来，并为每个节点分配一个唯一的 IP 地址。</span></div></div><details id="ixpJEHiUfjUX75X6FppfRA" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">工作原理</span></summary><div id="nG3zZCFJuPuYuQ3AFkA4SV" class="wolai-block wolai-text"><div><span class="blue inline-wrap">安装和配置 Flannel：</span><span class="inline-wrap">在 Kubernetes 集群中安装 Flannel，并根据集群的具体情况进行配置。Flannel 的配置主要包括覆盖网络的 CIDR 范围、用于分配 IP 地址的网段等。</span></div></div><div id="63yWNxFdNrKNZ2vXqW8Tjd" class="wolai-block wolai-text"><div><span class="blue inline-wrap">创建覆盖网络</span><span class="inline-wrap">：Flannel 在集群中创建覆盖网络，该覆盖网络将集群中的所有节点连接起来。覆盖网络通常使用 VXLAN 或 Geneve 等隧道技术来实现。</span></div></div><div id="44ajdY4sw9Eba2KmhkUnVb" class="wolai-block wolai-text"><div><span class="blue inline-wrap">分配 IP 地址</span><span class="inline-wrap">：Flannel 为集群中的每个节点分配一个唯一的 IP 地址。这些 IP 地址通常来自 Flannel 配置的网段。</span></div></div><div id="h9uVXYLWV7PcTcCizeaTgh" class="wolai-block wolai-text"><div><span class="blue inline-wrap">路由配置</span><span class="inline-wrap">：Flannel 在集群中的每个节点上配置路由表，以便节点能够相互通信以及与外部网络通信。Flannel 使用 BGP 协议来动态交换路由信息。</span></div></div><div id="hwErmqxqK8YLPCtRTwF5ns" class="wolai-block wolai-text"><div><span class="blue inline-wrap">服务发现</span><span class="inline-wrap">：Flannel 集成了 Kubernetes 的服务发现机制，使 Kubernetes 服务能够在集群内被发现和访问。</span></div></div></details><details id="k1crPybGSLxRoYsrWgfNFg" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">优点</span></summary><div id="mgUmaTjW3vu2CkaH6rAeMY" class="wolai-block wolai-text"><div><span class="blue inline-wrap">简单易用</span><span class="inline-wrap">：Flannel 的安装和配置非常简单，不需要对集群进行复杂的修改。</span></div></div><div id="hCyLDemeN5YB6fq3mLYhvj" class="wolai-block wolai-text"><div><span class="blue inline-wrap">可靠稳定</span><span class="inline-wrap">：Flannel 经过广泛的测试，具有很高的可靠性和稳定性。</span></div></div><div id="cLBjnSiCNeCySYXd2DvHJR" class="wolai-block wolai-text"><div><span class="inline-wrap">可扩展性强：Flannel 可以支持大规模的 Kubernetes 集群，并且随着集群的扩展，Flannel 能够自动调整覆盖网络的规模。</span></div></div><div id="mEEHvBGVjhGGxbpUSMetDA" class="wolai-block wolai-text"><div><span class="inline-wrap">跨平台支持：Flannel 支持多种平台，包括 Linux、Windows 和 macOS。</span></div></div></details><div id="4sBNYQSuLsFS6KBLK9cWvb" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details></details><details id="sMRbmrvyzFktBSKh6PUaoP" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">集群</span></summary><details id="pMfKUP5tWP8TXsSyj6JE1K" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">主节点</span></summary><div id="5XKjqcm1vkqhAp4k2Z2yVF" class="wolai-block wolai-text"><div><span class="inline-wrap">是组成集群的控制平面的系统服务的集合</span></div></div><aside id="atKauAPtfHWJFaQtvm4q2P" class="bg-cultured wolai-block"><div data-symbol="📌" class="icon"></div><span class="inline-wrap">并不包含<span class="jill"></span>kubeadm，因为<span class="jill"></span>kubeadm<span class="jill"></span>是初始化集群的工具，一旦集群初始化完成，kubeadm 就没有必要在主节点上运行了。</span></aside><details id="hWP5VVZTjmUcYoXYEF2urv" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">API Server</span></summary><div id="8eUsuDZtc9ZdnpBwFhidNS" class="wolai-block wolai-text"><div><span class="blue inline-wrap">作用：</span><span class="inline-wrap">完成组件之间的通信</span></div></div><div id="9C6jKQ69dKCQ5fq6jTjMUv" class="wolai-block wolai-text"><div><span class="blue inline-wrap">通信方式：</span><span class="inline-wrap">对外通过<span class="jill"></span>HTTPS<span class="jill"></span>的方式提供了<span class="jill"></span>Restful<span class="jill"></span>风格的<span class="jill"></span>AIP<span class="jill"></span>接结构</span></div></div></details><details id="Ep3AQpbsC4LUvjwJNW5su" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">集群存储</span></summary><div id="h3Mm6AFaZSD5YTWcnBEJWk" class="wolai-block wolai-text"><div><span class="blue inline-wrap">作用：</span><span class="inline-wrap">持久化地存储了整个集群的配置与状态</span></div></div><div id="hjdUo86uZXzfQwFPogushy" class="wolai-block wolai-text"><div><span class="blue inline-wrap">数据库：</span><span class="inline-wrap">etcd</span></div></div><div id="t1jtHXwNcu5q77vMbZnXXQ" class="wolai-block wolai-text"><div><span class="blue inline-wrap">注：</span><span class="inline-wrap">etcd<span class="jill"></span>使用业界流行的<span class="jill"></span>RAFT<span class="jill"></span>一致性算法来完成并发写操作对不同的工作节点的相同数据进行更新</span></div></div></details><details id="23YhctYpjbReFWTpd4ArCr" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">controller<span class="jill"></span>管理器</span></summary><div id="99TgBRQ5Yg9zJ7Jz7vy6kD" class="wolai-block wolai-text"><div><span class="blue inline-wrap">作用：</span><span class="inline-wrap">实现全部后台控制循环（工作节点<span class="jill"></span>controller、终端<span class="jill"></span>controller、副本<span class="jill"></span>controller），完成对集群的监控并对事件做出响应。</span></div></div><details id="fYJeUdxUxWFZuKCLZN89UQ" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">循环控制实现逻辑</span></summary><div id="hyC7u8J1GCHWnaojUA4Aje" class="wolai-block wolai-text"><div><span class="inline-wrap">获取期望状态</span></div></div><div id="26hmS488wqYuJz7w1qVgCn" class="wolai-block wolai-text"><div><span class="inline-wrap">观察当前状态</span></div></div><div id="cu7Lc1cnHsYVaaRArZUeFy" class="wolai-block wolai-text"><div><span class="inline-wrap">判断两者间的差异</span></div></div><div id="5fGgAq9jB5axFcwP2BeN9i" class="wolai-block wolai-text"><div><span class="inline-wrap">变更当前状态来消除差异点</span></div></div></details><details id="8jRMLy9eH2W46SS8dWSjjg" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">云<span class="jill"></span>controller<span class="jill"></span>管理器</span></summary><div id="hGaaCQsBZ2j3B9i34Ss4aQ" class="wolai-block wolai-text"><div><span class="inline-wrap">以下是云 Kubernetes 管理器和 Kubernetes 管理器的具体区别：</span></div></div><div id="bbtcFTR8ZNdyxwQ628sFC6" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 100px"><span class="inline-wrap">功能</span></th><th style="width: 100px"><span class="inline-wrap">云 Kubernetes 管理器</span></th><th style="width: 100px"><span class="inline-wrap">Kubernetes 管理器</span></th></tr></thead><tbody><tr><td><span class="inline-wrap">可用性</span></td><td><span class="inline-wrap">仅限特定云平台</span></td><td><span class="inline-wrap">任何云平台</span></td></tr><tr><td><span class="inline-wrap">自动部署</span></td><td><span class="inline-wrap">是</span></td><td><span class="inline-wrap">否</span></td></tr><tr><td><span class="inline-wrap">集成</span></td><td><span class="inline-wrap">集成到云平台的其他服务</span></td><td><span class="inline-wrap">集成到其他 Kubernetes 工具和插件</span></td></tr><tr><td><span class="inline-wrap">监控和分析</span></td><td><span class="inline-wrap">提供</span></td><td><span class="inline-wrap">可选</span></td></tr><tr><td><span class="inline-wrap">成本</span></td><td><span class="inline-wrap">取决于云平台的定价</span></td><td><span class="inline-wrap">免费</span></td></tr></tbody></table></div><div id="wjUM2Q6ehs9PyL9jfbueSw" class="wolai-block wolai-text"><div><span class="inline-wrap">drive_spreadsheet<span class="jill"></span>导出到 Google 表格</span></div></div></details></details><details id="7kh2tXc76rakX2Nupxeoco" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">调度器</span></summary><div id="nugoBPPZfJ8cyuXXxKqkUs" class="wolai-block wolai-text"><div><span class="blue inline-wrap">作用：</span><span class="inline-wrap">通过监听<span class="jill"></span>API Server<span class="jill"></span>来启动新的工作任务，并分配到适合的且处于正常运行状态的节点中。</span></div></div><div id="9PTczkWoaBwkx9hXUqcaXD" class="wolai-block wolai-text"><div><span class="blue inline-wrap">注意：</span><span class="inline-wrap">调度器并不负责执行任务，只是为当前任务选择一个合适的节点运行。</span></div></div></details></details><details id="KhbNQVZjooAEpSM8NYP7A" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">工作节点</span></summary><details id="2sxSEcpDtz2eHPRGxSYqjm" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">职责</span></summary><div id="bAAKhDeuxqLXw2cx8dhGGu" class="wolai-block wolai-text"><div><span class="inline-wrap">监听<span class="jill"></span>API Server<span class="jill"></span>分派的新任务。</span></div></div><div id="68CdYeCSmPdbinWX1NtRU4" class="wolai-block wolai-text"><div><span class="inline-wrap">执行新分派的任务</span></div></div><div id="jihND5dRy1s1gAJY93xp96" class="wolai-block wolai-text"><div><span class="inline-wrap">向控制平面回复任务执行的结果（通过<span class="jill"></span>API Server）</span></div></div></details><details id="odGiipBdiYL2FhQrW7C5Us" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">功能</span></summary><details id="or8nMNJ8nLtnxtxHaVApdS" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">Kubelet</span></summary><div id="iqEorRLcTnzV6zJu82Pyx1" class="wolai-block wolai-text"><div><span class="blue inline-wrap">描述：</span><span class="inline-wrap">Kubelet<span class="jill"></span>是每个工作节点上的核心部分，是<span class="jill"></span>Kubernetes<span class="jill"></span>中重要的代理端，并且在集群中的每个工作节点上都有部署。</span></div></div><div id="jgf3p82iAzmV5LyJJGKrBw" class="wolai-block wolai-text"><div><span class="blue inline-wrap">说明：</span><span class="inline-wrap">实际上，通常工作节点与<span class="jill"></span>Kubelet<span class="jill"></span>这两个术语基本上是等价的。</span></div></div><div id="fGhF8kd8hKnaYMFCdQ36j6" class="wolai-block wolai-text"><div><span class="blue inline-wrap">运行过程：</span><span class="inline-wrap">在一个新的工作节点加入集群之后，Kubelet<span class="jill"></span>就会被部署到新节点上。然后<span class="jill"></span>Kubelet<span class="jill"></span>负责将当前工作节点注册到集群当中，集群的资源池就会获取到当前工作节点的<span class="jill"></span>CPU、内存以及存储信息，并将工作节点加入当前资源池。</span></div></div><div id="pnHJoGUMf5hm5vg97vZaPV" class="wolai-block wolai-text"><div><span class="blue inline-wrap">职责：</span><span class="inline-wrap">负责监听<span class="jill"></span>API Server<span class="jill"></span>新分配的任务（Kubelet<span class="jill"></span>仅仅是将这个消息上报给控制平面，又控制平面决定接下来如何做）</span></div></div><div id="vUbFf4Bv7AFxmiS1mHc1s3" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details id="ide4FE94BaqekRmauomJAq" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">容器运行时（Container runtiime）</span></summary><div id="kKXxeh62bzmVpRJiKMDHRx" class="wolai-block wolai-text"><div><span class="inline-wrap">依赖容器才能执行任务</span></div></div><details id="5TXvg7YiKHUP9MoAFDNUpm" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">支持</span></summary><div id="xsPrr5q4nwjUFQ39PThuDQ" class="wolai-block wolai-text"><div><span class="inline-wrap">cri-containerd</span></div></div><div id="tsFMr81cLHGde1WDubL8HW" class="wolai-block wolai-text"><div><span class="inline-wrap">CNCF</span></div></div><div id="p7uPzugbHvNK2J6xMmLKU9" class="wolai-block wolai-text"><div><span class="inline-wrap">Docker</span></div></div></details></details><details id="eB973gXyyQ3RBDpXvnRf2G" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">kube-proxy</span></summary><div id="cYRy2meqEcFAsC15eH1R9d" class="wolai-block wolai-text"><div><span class="blue inline-wrap">意义：</span><span class="inline-wrap">保证了每个工作节点都可以获取到唯一的<span class="jill"></span>IP<span class="jill"></span>地址，病史吸纳<span class="jill"></span>IPT-ABLE<span class="jill"></span>以及<span class="jill"></span>IPVS<span class="jill"></span>来保障<span class="jill"></span>Pod<span class="jill"></span>间网络路由与负载均衡。</span></div></div></details></details><div id="jhAYaUnmkw7Tyi21LbhkRt" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div></details><details id="5BuKxdySLLXScPVU4ccPtS" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">DNS</span></summary><div id="pVWj5Hm9jX3xr9b3eAFhWC" class="wolai-block wolai-text"><div><span class="inline-wrap">集群<span class="jill"></span>DNS<span class="jill"></span>服务有一个静态<span class="jill"></span>IP<span class="jill"></span>地址，并且这个<span class="jill"></span>IP<span class="jill"></span>地址集群总每个<span class="jill"></span>Pod<span class="jill"></span>上都是硬编码的，这意味着每个容器以及<span class="jill"></span>Pod<span class="jill"></span>都能找到<span class="jill"></span>DNS<span class="jill"></span>服务。每个新服务都会自动注册到集群<span class="jill"></span>DNS<span class="jill"></span>服务上</span></div></div></details></details></details><details id="ubo721zubBM8CtKXNsUgAH" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">k8s<span class="jill"></span>和<span class="jill"></span>docker</span></summary><div id="n4ExYqbnT4XbYWaRoMSqHN" class="wolai-block wolai-text"><div><span class="blue inline-wrap">说明：</span><span class="inline-wrap">k8<span class="jill"></span>和<span class="jill"></span>docker<span class="jill"></span>是两个互补的技术，比如会使用<span class="jill"></span>docker<span class="jill"></span>进行应用开发，然后用<span class="jill"></span>k8b<span class="jill"></span>在生产环境中对应用进行编排。</span></div></div><div id="6LYHqva9d7g4GaDCHAGjCu" class="wolai-block wolai-text"><div><span class="blue inline-wrap">区别：</span><span class="inline-wrap">从运行架构上来说，假设在某生产环境中的<span class="jill"></span>Kubernetes<span class="jill"></span>集群是由<span class="jill"></span>10<span class="jill"></span>个节点构成的。那么其中的每个节点都是以<span class="jill"></span>Docker<span class="jill"></span>作为其容器运行时（Container Runtime）。也就是说，Docker<span class="jill"></span>是一种更加偏向底层的技术，它负责诸如启停容器的操作；而<span class="jill"></span>Kubernetes<span class="jill"></span>是一种更加偏向上层的技术，它注重集群范畴的管理，比如决定在哪个节点上运行容器、决定什么适合进行扩缩容或升级。</span></div></div></details></div><div id="h63tSLni6HPzVevxbpqbXY" class="wolai-col" style="flex-grow: 0.5"><div id="e3q5MyvtYDPuj8iEZpFmRr" class="bg-fluorescent_green2 wolai-block wolai-text"><div><span class="inline-wrap">实用程序</span></div></div><div id="jHRHJk9Bn3auTxS6ikYzE8" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="kubectl/kubectl.html"><span>kubectl</span></a></div></div></div></article><footer></footer></body></html>