<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../../css/wolai.css"/><title>面试题 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="full-width small-font less-lead"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="面试题" class="main-title"></div></div></header><article><h1 id="wXDH8or8uDVYM2Sj2cxMcS" class="wolai-block"><span class="inline-wrap">Oracle SQL<span class="jill"></span>性能优化</span></h1><ol class="wolai-block"><li id="9GKXbVhXtvhWSzAxziAcoT"><div class="marker"></div><span class="inline-wrap">选择最有效率的表名顺序(RBO)</span><span class="inline-wrap">
</span><span class="inline-wrap">ORACLE<span class="jill"></span>的解析器按照从右到左的顺序处理<span class="jill"></span>FROM<span class="jill"></span>子句中的表名，FROM<span class="jill"></span>子句中写在最后的表(基础表 driving table)将被最先处理，在<span class="jill"></span>FROM<span class="jill"></span>子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有<span class="jill"></span>3<span class="jill"></span>个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.</span></li><li id="n1pXzdqGAfna2TprJdeDK9"><div class="marker"></div><span class="inline-wrap">WHERE<span class="jill"></span>子句中的连接顺序</span><span class="inline-wrap">
</span><span class="inline-wrap">ORACLE<span class="jill"></span>采用自下而上的顺序解析<span class="jill"></span>WHERE<span class="jill"></span>子句,根据这个原理,表之间的连接必须写在其他<span class="jill"></span>WHERE<span class="jill"></span>条件之前, 那些可以过滤掉最大数量记录的条件必须写在<span class="jill"></span>WHERE<span class="jill"></span>子句的末尾.</span></li><li id="dmo6RpT4gdJJoGXXMD1hUM"><div class="marker"></div><span class="inline-wrap">SELECT<span class="jill"></span>子句中避免使用*号</span><span class="inline-wrap">
</span><span class="inline-wrap">ORACLE<span class="jill"></span>在解析的过程中, 会将&#39; *&#39; 依次转换成所有的列名, 这个工作是通过查询</span><span class="inline-wrap">ORACLE<span class="jill"></span>在解析的过程中, 会将&#39; *&#39; 依次转换成所有的列名, 这个工作是通过查询</span><span class="inline-wrap"><b>数据字典</b></span><span class="inline-wrap">完成的, 这意味着将耗费更多的时间</span></li><li id="vJGfC131QbVpgRXzfAw1kB"><div class="marker"></div><span class="inline-wrap">减少访问数据库的次数</span><span class="inline-wrap">
</span><span class="inline-wrap">ORACLE<span class="jill"></span>在内部执行了许多工作: 解析<span class="jill"></span>SQL<span class="jill"></span>语句, 估算索引的利用率, 绑定变量 , 读数据块等；</span></li><li id="bHDJ95R2ngQ9LctAzkbawz"><div class="marker"></div><span class="inline-wrap"><a href="https://www.cnblogs.com/zjpeng/p/10757559.html"><span>行预取</span></a></span><span class="inline-wrap">
</span><span class="inline-wrap">在<span class="jill"></span>SQL*Plus , SQL*Forms<span class="jill"></span>和<span class="jill"></span>Pro*C<span class="jill"></span>中重新设置<span class="jill"></span>ARRAYSIZE<span class="jill"></span>参数, 可以增加每次数据库访问的检索数据量 ,可设定值范围<span class="jill"></span>1-5000,建议值为<span class="jill"></span>200</span></li><li id="6jWKEhnxzEHaSFmsBzNCN4"><div class="marker"></div><span class="inline-wrap">使用</span><span class="inline-wrap"><a href="https://www.cnblogs.com/fengjunming/p/7966441.html"><span>DECODE</span></a></span><span class="inline-wrap">函数来减少处理时间</span><span class="inline-wrap">
</span><span class="inline-wrap">使用<span class="jill"></span>DECODE<span class="jill"></span>函数可以避免重复扫描相同记录或重复连接相同的表.</span><code-block id="h35rwYHj1NdQqbiM3uzsx5" class="wolai-block"><div class="wolai-pre"><div data-lang="纯文本" class="marker"></div><pre><span class="token function">decode</span><span class="token punctuation">(</span>条件<span class="token punctuation">,</span>值<span class="token number">1</span><span class="token punctuation">,</span>返回值<span class="token number">1</span><span class="token punctuation">,</span>值<span class="token number">2</span><span class="token punctuation">,</span>返回值<span class="token number">2</span><span class="token punctuation">,</span><span class="token spread operator">...</span>值n<span class="token punctuation">,</span>返回值n<span class="token punctuation">,</span>缺省值<span class="token punctuation">)</span></pre></div></code-block></li><li id="1eZdRiuo4ztKN8JpgpgFSo"><div class="marker"></div><span class="inline-wrap">整合简单,无关联的数据库访问</span><span class="inline-wrap">
</span><span class="inline-wrap">如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)</span></li><li id="aCJV6XvtfQ4qTsL9usFYR8"><div class="marker"></div><span class="inline-wrap">删除重复记录</span><span class="inline-wrap">
</span><span class="inline-wrap">使用<span class="jill"></span>ROWID：最高效的删除重复记录方法：</span><code-block id="vHif8NDqoU4BiJHKNpjY2v" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> EMP E 
<span class="token keyword">WHERE</span> E<span class="token punctuation">.</span>ROWID <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>ROWID<span class="token punctuation">)</span> <span class="token keyword">FROM</span> EMP X <span class="token keyword">WHERE</span> X<span class="token punctuation">.</span>EMP_NO <span class="token operator">=</span> E<span class="token punctuation">.</span>EMP_NO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="rmcWB5S5K4kbAF8SCNi9g2"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>TRUNCATE<span class="jill"></span>替代<span class="jill"></span>DELETE，速度：drop&gt; truncate &gt; delete</span><span class="inline-wrap">
</span><span class="inline-wrap">truncate 和 delete 只删除数据不删除表的结构(定义)
drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。</span></li><li id="gqJbsnxz1MQ9Ux6UGiayes"><div class="marker"></div><span class="inline-wrap">delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动
drop 语句将表所占用的空间全部释放。</span></li><li id="cZhAQtSSBhXtcBJKkTRgyh"><div class="marker"></div><span class="inline-wrap">truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。truncate 语句缺省情况下见空间释放到 minextents<span class="jill"></span>个 extent，除非使用<span class="jill"></span>reuse storage；truncate 会将高水线复位(回到最开始)。</span></li><li id="aVJym8GRETHBzTA14PoLAh"><div class="marker"></div><span class="inline-wrap">尽量多使用<span class="jill"></span>COMMIT</span><span class="inline-wrap">
</span><span class="inline-wrap">只要有可能,在程序中尽量多使用<span class="jill"></span>COMMIT, 这样程序的性能得到提高,需求也会因为<span class="jill"></span>COMMIT<span class="jill"></span>所释放的资源而减少。</span><span class="inline-wrap">
</span><span class="inline-wrap">COMMIT<span class="jill"></span>所释放的资源:</span><ul class="wolai-block"><li id="fBh71iWL3BTjDJHaaZHieV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">回滚段上用于恢复数据的信息</span></li><li id="7DYx8bqyhHRrL4NZmTPWwZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">被程序语句获得的锁</span></li><li id="oK1rNb2gxybq4HUTWaYkoA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">redo log buffer 中的空间</span></li><li id="nESJuZfW2rmZCU72N5RVag"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ORACLE<span class="jill"></span>为管理上述<span class="jill"></span>3<span class="jill"></span>种资源中的内部花费</span></li></ul></li><li id="8iMSxe32JynSiJicEAfqCu"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>Where<span class="jill"></span>子句替换<span class="jill"></span>HAVING<span class="jill"></span>子句</span><span class="inline-wrap">
</span><span class="inline-wrap">避免使用<span class="jill"></span>HAVING<span class="jill"></span>子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作. 如果能通过<span class="jill"></span>WHERE<span class="jill"></span>子句限制记录的数目,那就能减少这方面的开销。</span><span class="inline-wrap">
</span><span class="inline-wrap">on<span class="jill"></span>是最先执行，where<span class="jill"></span>次之，having<span class="jill"></span>最后，因为<span class="jill"></span>on<span class="jill"></span>是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，where<span class="jill"></span>也应该比<span class="jill"></span>having<span class="jill"></span>快点的，因为它过滤数据后才进行<span class="jill"></span>sum，在两个表联接时才用<span class="jill"></span>on<span class="jill"></span>的，所以在一个表的时候，就剩下<span class="jill"></span>where<span class="jill"></span>跟<span class="jill"></span>having<span class="jill"></span>比较了。</span></li><li id="hniBv6ECTu8mR2VkscH3uD"><div class="marker"></div><span class="inline-wrap">减少对表的查询</span><span class="inline-wrap">
</span><span class="inline-wrap">在含有子查询的<span class="jill"></span>SQL<span class="jill"></span>语句中,要特别注意减少对表的查询.例子：</span><code-block id="jsQUtRpUQ84ay6sodxBsvG" class="wolai-block"><div class="wolai-pre"><div data-lang="SQL" class="marker"></div><pre><span class="token keyword">SELECT</span> TAB_NAME 
<span class="token keyword">FROM</span> <span class="token keyword">TABLES</span> 
<span class="token keyword">WHERE</span> <span class="token punctuation">(</span>TAB_NAME<span class="token punctuation">,</span>DB_VER<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> TAB_NAME<span class="token punctuation">,</span>DB_VER <span class="token keyword">FROM</span> TAB_COLUMNS <span class="token keyword">WHERE</span> VERSION <span class="token operator">=</span> <span class="token number">604</span><span class="token punctuation">)</span></pre></div></code-block></li><li id="9TmpVquL3rb4fhifyb4Bgn"><div class="marker"></div><span class="inline-wrap">通过内部函数提高<span class="jill"></span>SQL<span class="jill"></span>效率</span><span class="inline-wrap">
</span><span class="inline-wrap">复杂的<span class="jill"></span>SQL<span class="jill"></span>往往牺牲了执行效率. 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的</span></li><li id="h6FyS4TTSKb8NTGtHb62z7"><div class="marker"></div><span class="inline-wrap">使用表的别名(Alias)</span><span class="inline-wrap">
</span><span class="inline-wrap">当在<span class="jill"></span>SQL<span class="jill"></span>语句中连接多个表时, 请使用表的别名并把别名前缀于每个<span class="jill"></span>Column<span class="jill"></span>上.这样一来,就可以减少解析的时间并减少那些由<span class="jill"></span>Column<span class="jill"></span>歧义引起的语法错误.</span></li><li id="5dNUXZ8Y5aXLqn5XRxaqHu"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>EXISTS<span class="jill"></span>替代<span class="jill"></span>IN、用<span class="jill"></span>NOT EXISTS<span class="jill"></span>替代<span class="jill"></span>NOT IN</span><span class="inline-wrap">
</span><span class="inline-wrap">在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用<span class="jill"></span>EXISTS(或<span class="jill"></span>NOT EXISTS)通常将提高查询的效率.</span><span class="inline-wrap">
</span><span class="inline-wrap">在子查询中,NOT IN<span class="jill"></span>子句将执行一个内部的排序和合并. 无论在哪种情况下,NOT IN<span class="jill"></span>都是最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用<span class="jill"></span>NOT IN ,我们可以把它改写成外连接(Outer Joins)或<span class="jill"></span>NOT EXISTS.</span><code-block id="syqMf7gETXD7ufCsNsGCPk" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 高效</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> EMPNO <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">AND</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token string">'X'</span> <span class="token keyword">FROM</span> DEPT <span class="token keyword">WHERE</span> DEPT<span class="token punctuation">.</span>DEPTNO <span class="token operator">=</span> EMP<span class="token punctuation">.</span>DEPTNO <span class="token operator">AND</span> LOC <span class="token operator">=</span> <span class="token string">'MELB'</span><span class="token punctuation">)</span> 
<span class="token comment">-- 低效</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> EMPNO <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">AND</span> DEPTNO <span class="token operator">IN</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> DEPTNO <span class="token keyword">FROM</span> DEPT <span class="token keyword">WHERE</span> LOC <span class="token operator">=</span> <span class="token string">'MELB'</span><span class="token punctuation">)</span> </pre></div></code-block></li><li id="uN9eor2UGorRxC3PFjiint"><div class="marker"></div><span class="inline-wrap">识别&#39;低效执行&#39;的<span class="jill"></span>SQL<span class="jill"></span>语句</span><code-block id="53v7BfhBTyYdcWqxeNzfER" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token keyword">SELECT</span> EXECUTIONS <span class="token punctuation">,</span> DISK_READS<span class="token punctuation">,</span> BUFFER_GETS<span class="token punctuation">,</span> 
<span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token punctuation">(</span>BUFFER_GETS<span class="token operator">-</span>DISK_READS<span class="token punctuation">)</span><span class="token operator">/</span>BUFFER_GETS<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> Hit_radio<span class="token punctuation">,</span> 
<span class="token function">ROUND</span><span class="token punctuation">(</span>DISK_READS<span class="token operator">/</span>EXECUTIONS<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> Reads_per_run<span class="token punctuation">,</span> 
SQL_TEXT 
<span class="token keyword">FROM</span> V$SQLAREA 
<span class="token keyword">WHERE</span> EXECUTIONS<span class="token operator">></span><span class="token number">0</span> 
<span class="token operator">AND</span> BUFFER_GETS <span class="token operator">></span> <span class="token number">0</span> 
<span class="token operator">AND</span> <span class="token punctuation">(</span>BUFFER_GETS<span class="token operator">-</span>DISK_READS<span class="token punctuation">)</span><span class="token operator">/</span>BUFFER_GETS <span class="token operator">&lt;</span> <span class="token number">0.8</span> 
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token number">4</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span> </pre></div></code-block></li><li id="3hXXivxZZGmBDF3jRrAsRn"><div class="marker"></div><span class="inline-wrap">用索引提高效率</span><span class="inline-wrap">
</span><span class="inline-wrap">索引是表的一个概念部分,用来提高检索数据的效率，ORACLE<span class="jill"></span>使用了一个复杂的自平衡<span class="jill"></span>B-tree<span class="jill"></span>结构. 通常,通过索引查询数据比全表扫描要快. 当<span class="jill"></span>ORACLE<span class="jill"></span>找出执行查询和<span class="jill"></span>Update<span class="jill"></span>语句的最佳路径时, ORACLE<span class="jill"></span>优化器将使用索引. 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.。那些<span class="jill"></span>LONG<span class="jill"></span>或<span class="jill"></span>LONG RAW<span class="jill"></span>数据类型, 你可以索引几乎所有的列. 通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率. 虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的<span class="jill"></span>INSERT , DELETE , UPDATE<span class="jill"></span>将为此多付出<span class="jill"></span>4 , 5 次的磁盘<span class="jill"></span>I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的.：
ALTER INDEX </span><span class="inline-wrap">&lt;INDEXNAME&gt;</span><span class="inline-wrap"> REBUILD </span><span class="inline-wrap">&lt;TABLESPACENAME&gt;</span></li><li id="4SBqmRfDyMCSjo7C7Z6sbt"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>EXISTS<span class="jill"></span>替换<span class="jill"></span>DISTINCT</span><span class="inline-wrap">
</span><span class="inline-wrap">当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在<span class="jill"></span>SELECT<span class="jill"></span>子句中使用<span class="jill"></span>DISTINCT. 一般可以考虑用<span class="jill"></span>EXIST<span class="jill"></span>替换, EXISTS 使查询更为迅速,因为<span class="jill"></span>RDBMS<span class="jill"></span>核心模块将在子查询的条件一旦满足后,立刻返回结果. 例子：
(低效):
SELECT DISTINCT DEPT_NO,DEPT_NAME FROM DEPT D , EMP E
WHERE D.DEPT_NO = E.DEPT_NO
(高效):
SELECT DEPT_NO,DEPT_NAME FROM DEPT D WHERE EXISTS ( SELECT ‘X&#39;
FROM EMP E WHERE E.DEPT_NO = D.DEPT_NO);</span></li><li id="pgDv8V3qXbnZq5gp6Qj555"><div class="marker"></div><span class="inline-wrap">sql<span class="jill"></span>语句用大写的</span><span class="inline-wrap">
</span><span class="inline-wrap">因为<span class="jill"></span>oracle<span class="jill"></span>总是先解析<span class="jill"></span>sql<span class="jill"></span>语句，把小写的字母转换成大写的再执行</span></li><li id="wNAb6Avf1H8SDAWtGkoG94"><div class="marker"></div><span class="inline-wrap">在<span class="jill"></span>java<span class="jill"></span>代码中尽量少用连接符“＋”连接字符串！</span></li><li id="phYvVw3xNEGxk7r9KQpF22"><div class="marker"></div><span class="inline-wrap">避免在索引列上使用<span class="jill"></span>NOT</span><span class="inline-wrap">
</span><span class="inline-wrap">通常，我们要避免在索引列上使用<span class="jill"></span>NOT, NOT<span class="jill"></span>会产生在和在索引列上使用函数相同的影响. 当<span class="jill"></span>ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描.</span></li><li id="qQaghprwGHP6NgjWisbrsJ"><div class="marker"></div><span class="inline-wrap">避免在索引列上使用计算</span><span class="inline-wrap">
</span><span class="inline-wrap">WHERE<span class="jill"></span>子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．</span><code-block id="meGtt2Ms3nS9fWabbzUqme" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 低效</span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> DEPT <span class="token keyword">WHERE</span> SAL <span class="token operator">*</span> <span class="token number">12</span> <span class="token operator">></span> <span class="token number">25000</span><span class="token punctuation">;</span> 
<span class="token comment">-- 高效</span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> DEPT <span class="token keyword">WHERE</span> SAL <span class="token operator">></span> <span class="token number">25000</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="hzxRcKtivYU9ceEXNV3QsP"><div class="marker"></div><span class="inline-wrap">用&gt;=替代&gt;</span><code-block id="aAL2MNBzeFgszo584LsnwF" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 高效</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> DEPTNO <span class="token operator">>=</span><span class="token number">4</span> 
<span class="token comment">-- 低效</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> DEPTNO <span class="token operator">></span><span class="token number">3</span> </pre></div></code-block><div id="g7LxVxAPW5YRRgc8LeXHWX" class="wolai-block wolai-text"><div><span class="inline-wrap">两者的区别在于, 前者<span class="jill"></span>DBMS<span class="jill"></span>将直接跳到第一个<span class="jill"></span>DEPT<span class="jill"></span>等于<span class="jill"></span>4<span class="jill"></span>的记录而后者将首先定位到<span class="jill"></span>DEPTNO=3<span class="jill"></span>的记录并且向前扫描到第一个<span class="jill"></span>DEPT<span class="jill"></span>大于<span class="jill"></span>3<span class="jill"></span>的记录.</span></div></div></li><li id="nYQHPeBCg57f3rZci9hCq2"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>UNION<span class="jill"></span>替换<span class="jill"></span>OR (适用于索引列)</span><span class="inline-wrap">
</span><span class="inline-wrap">通常情况下, 用<span class="jill"></span>UNION<span class="jill"></span>替换<span class="jill"></span>WHERE<span class="jill"></span>子句中的<span class="jill"></span>OR<span class="jill"></span>将会起到较好的效果. 对索引列使用<span class="jill"></span>OR<span class="jill"></span>将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有<span class="jill"></span>column<span class="jill"></span>没有被索引, 查询效率可能会因为你没有选择<span class="jill"></span>OR<span class="jill"></span>而降低. 在下面的例子中, LOC_ID 和<span class="jill"></span>REGION<span class="jill"></span>上都建有索引.</span><code-block id="jvsErFYokDFniaaBkyA59N" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 低效</span>
<span class="token keyword">SELECT</span> LOC_ID <span class="token punctuation">,</span> LOC_DESC <span class="token punctuation">,</span> REGION 
<span class="token keyword">FROM</span> LOCATION 
<span class="token keyword">WHERE</span> LOC_ID <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">OR</span> REGION <span class="token operator">=</span> <span class="token string">"MELBOURNE"</span>
<span class="token comment">-- 高效 </span>
<span class="token keyword">SELECT</span> LOC_ID <span class="token punctuation">,</span> LOC_DESC <span class="token punctuation">,</span> REGION 
<span class="token keyword">FROM</span> LOCATION 
<span class="token keyword">WHERE</span> LOC_ID <span class="token operator">=</span> <span class="token number">10</span> 
<span class="token keyword">UNION</span> 
<span class="token keyword">SELECT</span> LOC_ID <span class="token punctuation">,</span> LOC_DESC <span class="token punctuation">,</span> REGION 
<span class="token keyword">FROM</span> LOCATION 
<span class="token keyword">WHERE</span> REGION <span class="token operator">=</span> <span class="token string">"MELBOURNE"</span></pre></div></code-block><div id="qCRqLNLoRMmSoiRW5TeNng" class="wolai-block wolai-text"><div><span class="inline-wrap">如果你坚持要用<span class="jill"></span>OR, 那就需要返回记录最少的索引列写在最前面</span></div></div></li><li id="pXftKuU1EBC88FciCwb2vN"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>IN<span class="jill"></span>来替换<span class="jill"></span>OR</span><span class="inline-wrap">
</span><span class="inline-wrap">这是一条简单易记的规则，但是实际的执行效果还须检验，在<span class="jill"></span>ORACLE8i<span class="jill"></span>下，两者的执行路径似乎是相同的</span><code-block id="nt6TU6BeuKpA6WNAaoQHTi" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 低效 </span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> LOCATION <span class="token keyword">WHERE</span> LOC_ID <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">OR</span> LOC_ID <span class="token operator">=</span> <span class="token number">20</span> <span class="token operator">OR</span> LOC_ID <span class="token operator">=</span> <span class="token number">30</span>
<span class="token comment">-- 高效 </span>
<span class="token keyword">SELECT</span>… <span class="token keyword">FROM</span> LOCATION <span class="token keyword">WHERE</span> LOC_IN <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="56YfTnAcSVRXv6HzRJxvU2"><div class="marker"></div><span class="inline-wrap">避免在索引列上使用<span class="jill"></span>IS NULL<span class="jill"></span>和<span class="jill"></span>IS NOT NULL</span><span class="inline-wrap">
</span><span class="inline-wrap">避免在索引中使用任何可以为空的列，ORACLE<span class="jill"></span>将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录. 对于复合索引，如果每个列都为空，索引中同样不存在此记录.　如果至少有一个列不为空，则记录存在于索引中．举例: 如果唯一性索引建立在表的<span class="jill"></span>A<span class="jill"></span>列和<span class="jill"></span>B<span class="jill"></span>列上, 并且表中存在一条记录的<span class="jill"></span>A,B<span class="jill"></span>值为(123,null) , ORACLE<span class="jill"></span>将不接受下一条具有相同<span class="jill"></span>A,B<span class="jill"></span>值（123,null）的记录(插入). 然而如果所有的索引列都为空，ORACLE<span class="jill"></span>将认为整个键值为空而空不等于空. 因此你可以插入<span class="jill"></span>1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以<span class="jill"></span>WHERE<span class="jill"></span>子句中对索引列进行空值比较将使<span class="jill"></span>ORACLE<span class="jill"></span>停用该索引.</span><code-block id="6hnyvFRPsvqpqJTyGeBUk6" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 低效: (索引失效) </span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> DEPARTMENT <span class="token keyword">WHERE</span> DEPT_CODE <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span> 
<span class="token comment">-- 高效: (索引有效) </span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> DEPARTMENT <span class="token keyword">WHERE</span> DEPT_CODE <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> </pre></div></code-block></li><li id="9v7L9ay2xQ7X96Vy3ruwyA"><div class="marker"></div><span class="inline-wrap">总是使用索引的第一个列</span><span class="inline-wrap">
</span><span class="inline-wrap">如果索引是建立在多个列上, 只有在它的第一个列(leading column)被<span class="jill"></span>where<span class="jill"></span>子句引用时,优化器才会选择使用该索引. 这也是一条简单而重要的规则，当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引</span></li><li id="5k8QCtXAcHn6Ehzh7sYBav"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>UNION-ALL 替换<span class="jill"></span>UNION ( 如果有可能的话)</span><span class="inline-wrap">
</span><span class="inline-wrap">当<span class="jill"></span>SQL<span class="jill"></span>语句需要<span class="jill"></span>UNION<span class="jill"></span>两个查询结果集合时,这两个结果集合会以<span class="jill"></span>UNION-ALL<span class="jill"></span>的方式被合并, 然后在输出最终结果前进行排序. 如果用<span class="jill"></span>UNION ALL<span class="jill"></span>替代<span class="jill"></span>UNION, 这样排序就不是必要了. 效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录. 因此各位还是要从业务需求分析使用<span class="jill"></span>UNION ALL<span class="jill"></span>的可行性. UNION 将对结果集合排序,这个操作会使用到<span class="jill"></span>SORT_AREA_SIZE<span class="jill"></span>这块内存. 对于这块内存的优化也是相当重要的. 下面的<span class="jill"></span>SQL<span class="jill"></span>可以用来查询排序的消耗量</span><code-block id="nDQj1FgHAoo4H2yg59NHX5" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 低效</span>
<span class="token keyword">SELECT</span> ACCT_NUM<span class="token punctuation">,</span> BALANCE_AMT 
<span class="token keyword">FROM</span> DEBIT_TRANSACTIONS 
<span class="token keyword">WHERE</span> TRAN_DATE <span class="token operator">=</span> <span class="token string">'31-DEC-95'</span> 
<span class="token keyword">UNION</span> 
<span class="token keyword">SELECT</span> ACCT_NUM<span class="token punctuation">,</span> BALANCE_AMT 
<span class="token keyword">FROM</span> DEBIT_TRANSACTIONS 
<span class="token keyword">WHERE</span> TRAN_DATE <span class="token operator">=</span> <span class="token string">'31-DEC-95'</span> 
<span class="token comment">-- 高效:</span>
<span class="token keyword">SELECT</span> ACCT_NUM<span class="token punctuation">,</span> BALANCE_AMT 
<span class="token keyword">FROM</span> DEBIT_TRANSACTIONS 
<span class="token keyword">WHERE</span> TRAN_DATE <span class="token operator">=</span> <span class="token string">'31-DEC-95'</span> 
<span class="token keyword">UNION</span> <span class="token keyword">ALL</span> 
<span class="token keyword">SELECT</span> ACCT_NUM<span class="token punctuation">,</span> BALANCE_AMT 
<span class="token keyword">FROM</span> DEBIT_TRANSACTIONS 
<span class="token keyword">WHERE</span> TRAN_DATE <span class="token operator">=</span> <span class="token string">'31-DEC-95'</span></pre></div></code-block></li><li id="aowdCwUHbLwYk9ZdrkdEdC"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>WHERE<span class="jill"></span>替代<span class="jill"></span>ORDER BY</span><span class="inline-wrap">
</span><span class="inline-wrap">ORDER BY 子句只在两种严格的条件下使用索引.
ORDER BY<span class="jill"></span>中所有的列必须包含在相同的索引中并保持在索引中的排列顺序.
ORDER BY<span class="jill"></span>中所有的列必须定义为非空.
WHERE<span class="jill"></span>子句使用的索引和<span class="jill"></span>ORDER BY<span class="jill"></span>子句中所使用的索引不能并列.</span><code-block id="m6JARe9BKPLymYrpuRGxnh" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">/* 表DEPT包含以下列: 
DEPT_CODE PK NOT NULL 
DEPT_DESC NOT NULL 
DEPT_TYPE NULL */</span>

<span class="token comment">-- 低效: (索引不被使用) </span>
<span class="token keyword">SELECT</span> DEPT_CODE <span class="token keyword">FROM</span> DEPT <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> DEPT_TYPE
<span class="token comment">-- 高效: (使用索引) </span>
<span class="token keyword">SELECT</span> DEPT_CODE <span class="token keyword">FROM</span> DEPT <span class="token keyword">WHERE</span> DEPT_TYPE <span class="token operator">></span> <span class="token number">0</span></pre></div></code-block></li><li id="d91mmx5vHzbBRfiLXjYKNR"><div class="marker"></div><span class="inline-wrap">避免改变索引列的类型</span><span class="inline-wrap">
</span><span class="inline-wrap">当比较不同数据类型的数据时, ORACLE<span class="jill"></span>自动对列进行简单的类型转换</span><span class="inline-wrap">
</span><span class="inline-wrap">为了避免<span class="jill"></span>ORACLE<span class="jill"></span>对你的<span class="jill"></span>SQL<span class="jill"></span>进行隐式的类型转换, 最好把类型转换用显式表现出来.</span><span class="inline-wrap">
</span><span class="inline-wrap">注意当字符和数值比较时, ORACLE<span class="jill"></span>会优先转换数值类型到字符类型</span><code-block id="pytKDevMs9gCBkW4ucvJJM" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- EMPNO是一个数值类型的索引列</span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> EMPNO <span class="token operator">=</span> <span class="token string">'123'</span><span class="token punctuation">;</span>
<span class="token comment">-- 被ORACLE转换为</span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> EMPNO <span class="token operator">=</span> TO_NUMBER<span class="token punctuation">(</span>‘<span class="token number">123</span>'<span class="token punctuation">)</span> </pre></div></code-block><div id="afePcdJ8jupSKJGiwF9Rkj" class="wolai-block wolai-text"><div><span class="inline-wrap">幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变</span></div></div><code-block id="p2QNSV22qr7tbCWVuHphYJ" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 假设EMP_TYPE是一个字符类型的索引列</span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> EMP_TYPE <span class="token operator">=</span> <span class="token number">123</span>
<span class="token comment">-- 被ORACLE转换为</span>
<span class="token keyword">SELECT</span> … <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> TO_NUMBER<span class="token punctuation">(</span>EMP_TYPE<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">123</span></pre></div></code-block><div id="1HtUfVFQuChb8fFXjsHdLy" class="wolai-block wolai-text"><div><span class="inline-wrap">因为内部发生的类型转换, 这个索引将不会被用到!</span></div></div></li><li id="4gCqq72jUBFn5KNrM11HzX"><div class="marker"></div><span class="inline-wrap">需要当心的<span class="jill"></span>WHERE<span class="jill"></span>子句,某些<span class="jill"></span>SELECT 语句中的<span class="jill"></span>WHERE<span class="jill"></span>子句不使用索引.</span><ul class="wolai-block"><li id="dAwZEQoUDFjmeo246insSs"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">‘!=&#39; 将不使用索引. 记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中</span></li><li id="8BENET5sCYc4Vby7bfb1a3"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">‘||&#39;是字符连接函数. 就象其他函数那样, 停用了索引</span></li><li id="mJcudYJtugSdxW2gtNMLpB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">‘+&#39;是数学函数. 就象其他数学函数那样, 停用了索引</span></li><li id="fGj633363WD14iKK38oPeq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">相同的索引列不能互相比较,这将会启用全表扫描</span></li></ul></li><li id="xpguR5NcmLp1P9aZqvRi6N"><div class="marker"></div><span class="inline-wrap">索引效率</span><ul class="wolai-block"><li id="nno2N7MFR32Rr1s4ESpByX"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果检索数据量超过<span class="jill"></span>30%<span class="jill"></span>的表中记录数.使用索引将没有显著的效率提高</span></li><li id="qqbp4LRDibbBgNsnxXqRjR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍!</span></li></ul></li><li id="jhqKhhHB4prGXfgUnAi9Ho"><div class="marker"></div><span class="inline-wrap">避免使用耗费资源的操作</span><span class="inline-wrap">
</span><span class="inline-wrap">带有<span class="jill"></span>DISTINCT,UNION,MINUS,INTERSECT,ORDER BY<span class="jill"></span>的<span class="jill"></span>SQL<span class="jill"></span>语句会启动<span class="jill"></span>SQL<span class="jill"></span>引擎
执行耗费资源的排序(SORT)功能. DISTINCT<span class="jill"></span>需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有<span class="jill"></span>UNION, MINUS , INTERSECT<span class="jill"></span>的<span class="jill"></span>SQL<span class="jill"></span>语句都可以用其他方式重写. 如果你的数据库的<span class="jill"></span>SORT_AREA_SIZE<span class="jill"></span>调配得好, 使用<span class="jill"></span>UNION , MINUS, INTERSECT<span class="jill"></span>也是可以考虑的, 毕竟它们的可读性很强</span></li><li id="iPAeugpYfQwH5yLbHby5pA"><div class="marker"></div><span class="inline-wrap">优化<span class="jill"></span>GROUP BY</span><span class="inline-wrap">
</span><span class="inline-wrap">提高<span class="jill"></span>GROUP BY 语句的效率, 可以通过将不需要的记录在<span class="jill"></span>GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多.</span><code-block id="kY2b7rPMPH5HREZmtLG1W3" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 低效</span>
<span class="token keyword">SELECT</span> JOB <span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>SAL<span class="token punctuation">)</span> 
<span class="token keyword">FROM</span> EMP 
<span class="token keyword">GROUP</span> JOB 
<span class="token keyword">HAVING</span> JOB <span class="token operator">=</span> ‘PRESIDENT<span class="token string">' 
OR JOB = ‘MANAGER'</span>

<span class="token comment">-- 高效</span>
<span class="token keyword">SELECT</span> JOB <span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>SAL<span class="token punctuation">)</span> 
<span class="token keyword">FROM</span> EMP 
<span class="token keyword">WHERE</span> JOB <span class="token operator">=</span> ‘PRESIDENT<span class="token string">' 
OR JOB = ‘MANAGER'</span> 
<span class="token keyword">GROUP</span> JOB</pre></div></code-block></li><li id="8MHUbCXhdadkZMLZs4Vnvv"><div class="marker"></div><span class="inline-wrap">选择最有效率的表名顺序（笔试常考）</span><span class="inline-wrap">
</span><span class="inline-wrap">ORACLE<span class="jill"></span>的解析器按照从右到左的顺序处理<span class="jill"></span>FROM<span class="jill"></span>子句中的表名， FROM<span class="jill"></span>子句中写在最后的表将被最先处理，在<span class="jill"></span>FROM<span class="jill"></span>子句中包含多个表的情况下,你必须选择记录条数最少的表放在最后，如果有<span class="jill"></span>3<span class="jill"></span>个以上的表连接查询,那就需要选择那个被其他表所引用的表放在最后。</span><code-block id="nj9JPwGSsfJiu2pmP6bhnD" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 例如：查询员工的编号，姓名，工资，工资等级，部门名</span>
<span class="token keyword">select</span> emp<span class="token punctuation">.</span>empno<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>ename<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>sal<span class="token punctuation">,</span>salgrade<span class="token punctuation">.</span>grade<span class="token punctuation">,</span>dept<span class="token punctuation">.</span>dname
<span class="token keyword">from</span> salgrade<span class="token punctuation">,</span>dept<span class="token punctuation">,</span>emp
<span class="token keyword">where</span> <span class="token punctuation">(</span>emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>emp<span class="token punctuation">.</span>sal <span class="token operator">between</span> salgrade<span class="token punctuation">.</span>losal <span class="token operator">and</span> salgrade<span class="token punctuation">.</span>hisal<span class="token punctuation">)</span>  </pre></div></code-block><ul class="wolai-block"><li id="osgYNgRrPmnf8n5CnF8kv6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推</span></li><li id="k3bzfmxiwFuayA3XEJ6D5F"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推</span></li></ul></li><li id="vvvLMVTxUVwAuFUMgPqDt5"><div class="marker"></div><span class="inline-wrap">WHERE<span class="jill"></span>子句中的连接顺序（笔试常考）</span><span class="inline-wrap">
</span><span class="inline-wrap">ORACLE<span class="jill"></span>采用自右而左的顺序解析<span class="jill"></span>WHERE<span class="jill"></span>子句,根据这个原理,表之间的连接必须写在其他<span class="jill"></span>WHERE<span class="jill"></span>条件之左,
那些可以过滤掉最大数量记录的条件必须写在<span class="jill"></span>WHERE<span class="jill"></span>子句的之右。</span><code-block id="eymJrqZRozUUZPTM8Fn9ve" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 例如：查询员工的编号，姓名，工资，部门名  </span>
<span class="token keyword">select</span> emp<span class="token punctuation">.</span>empno<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>ename<span class="token punctuation">,</span>emp<span class="token punctuation">.</span>sal<span class="token punctuation">,</span>dept<span class="token punctuation">.</span>dname
<span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept
<span class="token keyword">where</span> <span class="token punctuation">(</span>emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno<span class="token punctuation">)</span> <span class="token operator">and</span> <span class="token punctuation">(</span>emp<span class="token punctuation">.</span>sal <span class="token operator">></span> <span class="token number">1500</span><span class="token punctuation">)</span>  </pre></div></code-block></li><li id="aqPCihzJF7rtgFmnSXgR1s"><div class="marker"></div><span class="inline-wrap">SELECT<span class="jill"></span>子句中避免使用</span><span class="inline-wrap"><i>号
ORACLE<span class="jill"></span>在解析的过程中,会将</i></span><span class="inline-wrap">依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。</span></li><li id="d4RwD4MPQXhMjj4xpL5ghp"><div class="marker"></div><span class="inline-wrap">整合简单，无关联的数据库访问</span></li><li id="8uHb3ddpgTLr8jt4ewZEkj"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>TRUNCATE<span class="jill"></span>替代<span class="jill"></span>DELETE</span></li><li id="tdub3hNL4e48tH5iRudN5J"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>WHERE<span class="jill"></span>子句替换<span class="jill"></span>HAVING<span class="jill"></span>子句
WHERE<span class="jill"></span>先执行，HAVING<span class="jill"></span>后执行</span></li><li id="9B8jnXCXtdxqLi9M5Geo3j"><div class="marker"></div><span class="inline-wrap">多使用内部函数提高<span class="jill"></span>SQL<span class="jill"></span>效率</span></li><li id="oTWg2VYKECd9GuhDn4NDB8"><div class="marker"></div><span class="inline-wrap">使用表的别名
salgrade s</span></li><li id="psV9tGm1bYsYEpC98hXZWh"><div class="marker"></div><span class="inline-wrap">使用列的别名
ename e</span></li><li id="awRqeXKWr7LbQD4pKLY2hv"><div class="marker"></div><span class="inline-wrap">用索引提高效率
在查询中，善用索引</span></li><li id="m33jxpdoJR7zK6RvaWMJY4"><div class="marker"></div><span class="inline-wrap">字符串型，能用=号，不用<span class="jill"></span>like
因为=号表示精确比较，like<span class="jill"></span>表示模糊比较</span></li><li id="ew581buWBECafhzTY9k9i8"><div class="marker"></div><span class="inline-wrap">SQL<span class="jill"></span>语句用大写的
因为<span class="jill"></span>Oracle<span class="jill"></span>服务器总是先将小写字母转成大写后，才执行
在<span class="jill"></span>eclipse<span class="jill"></span>中，先写小写字母，再通过<span class="jill"></span>ctrl+shift+X<span class="jill"></span>转大写;ctrl+shift+Y<span class="jill"></span>转小写</span></li><li id="mgPAup5TPF35t59DTswN6D"><div class="marker"></div><span class="inline-wrap">避免在索引列上使用<span class="jill"></span>NOT
因为<span class="jill"></span>Oracle<span class="jill"></span>服务器遇到<span class="jill"></span>NOT<span class="jill"></span>后，他就会停止目前的工作，转而执行全表扫描</span></li><li id="vqANnJbA1D2bDdKwZFvo5q"><div class="marker"></div><span class="inline-wrap">避免在索引列上使用计算
WHERE<span class="jill"></span>子句中，如果索引列是函数的一部分，优化器将不使用索引而使用全表扫描，这样会变得变慢</span><code-block id="cenzrMf4ThqYywjaaEo6Xp" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token comment">-- 例如，SAL列上有索引</span>
<span class="token comment">-- 低效：</span>
<span class="token keyword">SELECT</span> EMPNO<span class="token punctuation">,</span>ENAME <span class="token keyword">FROM</span> EMP 
<span class="token keyword">WHERE</span> SAL<span class="token operator">*</span><span class="token number">12</span> <span class="token operator">></span> <span class="token number">24000</span><span class="token punctuation">;</span>
<span class="token comment">-- 高效：</span>
<span class="token keyword">SELECT</span> EMPNO<span class="token punctuation">,</span>ENAME <span class="token keyword">FROM</span> EMP
<span class="token keyword">WHERE</span> SAL <span class="token operator">></span> <span class="token number">24000</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">;</span></pre></div></code-block></li><li id="tyZ7sHfRMQHRcnjTwwHgb4"><div class="marker"></div><span class="inline-wrap">用 &gt;= 替代 &gt;
低效：
SELECT * FROM EMP WHERE DEPTNO &gt; 3</span><span class="inline-wrap">
</span><span class="inline-wrap">首先定位到<span class="jill"></span>DEPTNO=3<span class="jill"></span>的记录并且扫描到第一个<span class="jill"></span>DEPT<span class="jill"></span>大于<span class="jill"></span>3<span class="jill"></span>的记录
高效：
SELECT * FROM EMP WHERE DEPTNO &gt;= 4</span><span class="inline-wrap">
</span><span class="inline-wrap">直接跳到第一个<span class="jill"></span>DEPT<span class="jill"></span>等于<span class="jill"></span>4<span class="jill"></span>的记录</span></li><li id="jbAVjGN4gssNmjvEt9tjRZ"><div class="marker"></div><span class="inline-wrap">用<span class="jill"></span>IN<span class="jill"></span>替代<span class="jill"></span>OR
select * from emp where sal = 1500 or sal = 3000 or sal = 800;
select * from emp where sal in (1500,3000,800);</span></li><li id="3ZZCfJ7b9KjhpqxJz7fkKz"><div class="marker"></div><span class="inline-wrap">总是使用索引的第一个列
如果索引是建立在多个列上，只有在它的第一个列被<span class="jill"></span>WHERE<span class="jill"></span>子句引用时，优化器才会选择使用该索引
当只引用索引的第二个列时，不引用索引的第一个列时，优化器使用了全表扫描而忽略了索引</span><code-block id="sRmW24dgxP71b6kmucmeTr" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token keyword">create</span> <span class="token keyword">index</span> emp_sal_job_idex
<span class="token keyword">on</span> emp<span class="token punctuation">(</span>sal<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">----------------------------------</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> job <span class="token operator">!=</span> <span class="token string">'SALES'</span><span class="token punctuation">;</span>  </pre></div></code-block></li><li id="oFudQyDXzE5hceWBFGmBfs"><div class="marker"></div><span class="inline-wrap">避免改变索引列的类型，显示比隐式更安全， 当字符和数值比较时，ORACLE<span class="jill"></span>会优先转换数值类型到字符类型</span><code-block id="dunVQZeBU6HjeejBXtxyAq" class="wolai-block"><div class="wolai-pre"><div data-lang="Sql" class="marker"></div><pre><span class="token keyword">select</span> <span class="token number">123</span> <span class="token operator">||</span> <span class="token string">'123'</span> <span class="token keyword">from</span> dual<span class="token punctuation">;</span></pre></div></code-block></li></ol></article><footer></footer></body></html>