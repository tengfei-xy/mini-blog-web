<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>说明 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="full-width small-font less-lead"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="说明" class="main-title"></div></div></header><article><h1 id="ieyLNJeuiELkLi3FRDKmEn" class="wolai-block"><span class="inline-wrap">Linux</span></h1><h2 id="ab73Ws4WxGZeutG5yoAhFo" class="wolai-block"><span class="inline-wrap">valgrind</span></h2><div id="eqybnHF5XezjBXboNi1gjd" class="wolai-block wolai-text"><div><span class="inline-wrap">Valgrind 是一个复杂的工具，用于查找低级编程错误，特别是涉及内存使用的错误。如使用未初始化的内存、使用已经释放了的内存、内存泄漏等。它与其他调试工具（如 GDB）不同，因为它可以自动检测许多内存管理和线程错误。Valgrind 还包括一系列灵活的工具，用于调试和剖析。例如，您可以使用 Valgrind 和 GDB 以及 vgdb（一个小程序）一起进行调试。</span></div></div><blockquote id="dwYXnZyQormKt3cyXcX1sM" class="wolai-block"><span class="inline-wrap">官网：</span><span class="inline-wrap"><a href="https://valgrind.org/docs/manual/manual-intro.html"><span>Valgrind</span></a></span><span class="inline-wrap">
</span><span class="inline-wrap">简介：</span><span class="inline-wrap"><a href="https://cloud.tencent.com/developer/article/2222984"><span>https://cloud.tencent.com/developer/article/2222984</span></a></span><span class="inline-wrap">
</span><span class="inline-wrap">其他平台：官方不支持<span class="jill"></span>macos，但[github](</span><span class="inline-wrap"><a href="https://github.com/LouisBrunner/valgrind-macos"><span>GitHub - LouisBrunner/valgrind-macos：具有最新<span class="jill"></span>macOS<span class="jill"></span>支持的<span class="jill"></span>valgrind<span class="jill"></span>镜像</span></a></span><span class="inline-wrap">)有针对<span class="jill"></span>macos<span class="jill"></span>的镜像应用，也有其他系统问题。</span></blockquote><h2 id="inGAomXFubyagfog6GsRJd" class="wolai-block"><span class="inline-wrap">dmalloc</span></h2><div id="3c7ugooLfoyypx1oQ1NEz9" class="wolai-block wolai-text"><div><span class="inline-wrap">dmalloc：一个用于检查<span class="jill"></span>C/C++<span class="jill"></span>内存泄漏的工具，能够精确指出哪个源文件的第几行发生了内存泄漏。</span></div></div><div id="45AEro75W5gZZAbyQf5PbV" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>使用<span class="jill"></span>dmalloc<span class="jill"></span>有两种方式：</b></span></div></div><ul class="wolai-block"><li id="veckA12BNjTkqCGxpVaZEN"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">只进行<span class="jill"></span>dmalloc<span class="jill"></span>静态库的编译链接</span></li></ul><div id="ix6Kna8t7Qs7aj1VSCEfjk" class="wolai-block wolai-text"><div><span class="inline-wrap">这种方式的好处是对于代码量比较大的现有程序，无需关心每个.c<span class="jill"></span>文件的编译细节，只需要将<span class="jill"></span>dmalloc<span class="jill"></span>静态库放在程序依赖的最后面即可<span class="jill"></span>¹。</span></div></div><ul class="wolai-block"><li id="fkRiwbUQ68tgtPpK7v8bv6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">引用头文件</span></li></ul><div id="ePtEh43vrHbZ6CExNfAinL" class="wolai-block wolai-text"><div><span class="inline-wrap">在每个要调试的.c<span class="jill"></span>程序文件中加入<span class="jill"></span>dmalloc.h<span class="jill"></span>文件的引用。这种方式的原理是使用<span class="jill"></span>dmalloc.h<span class="jill"></span>头文件的宏定义将需要调试的.c<span class="jill"></span>程序文件中的<span class="jill"></span>malloc<span class="jill"></span>替换为<span class="jill"></span>dmalloc_malloc。这种方式不需要了解不同<span class="jill"></span>CPU<span class="jill"></span>体系的汇编，不需要借助<span class="jill"></span>gdb<span class="jill"></span>等工具，因为编译宏的替换可以直接使用__FILE_ </span><span class="inline-wrap">在每个要调试的.c<span class="jill"></span>程序文件中加入<span class="jill"></span>dmalloc.h<span class="jill"></span>文件的引用。这种方式的原理是使用<span class="jill"></span>dmalloc.h<span class="jill"></span>头文件的宏定义将需要调试的.c<span class="jill"></span>程序文件中的<span class="jill"></span>malloc<span class="jill"></span>替换为<span class="jill"></span>dmalloc_malloc。这种方式不需要了解不同<span class="jill"></span>CPU<span class="jill"></span>体系的汇编，不需要借助<span class="jill"></span>gdb<span class="jill"></span>等工具，因为编译宏的替换可以直接使用__FILE_ </span><span class="inline-wrap"><i>、</i></span><span class="inline-wrap"><i>、</i></span><span class="inline-wrap"> _LINE__宏，所以得到的调试信息直接是可以看到的文件名/行号<span class="jill"></span>¹。</span><span class="inline-wrap"> _LINE__宏，所以得到的调试信息直接是可以看到的文件名/行号<span class="jill"></span>¹。</span></div></div><h2 id="i8GnPLEPPUPneuzuoigphg" class="wolai-block"><span class="inline-wrap">mtrace</span></h2><div id="6Um3KeCmSKuhoXRhLf9stG" class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://bing.com/search?q=linux进程内存泄漏检测工具"><span>mtrace</span></a></span><span class="inline-wrap">：是 GNU Glibc 自带的内存问题检测工具，，是一个 perl 脚本文件，通过调用 addr2line 命令来进行解析代码文件位置用来跟踪<span class="jill"></span>malloc<span class="jill"></span>和<span class="jill"></span>free<span class="jill"></span>的调用，可以在程序退出时输出内存泄漏的信息。、当 mtrace 函数被调用时，它会检查名为 MALLOC_TRACE 的环境变量的值，该变量应包含记录追踪信息的文件的路径名。如果成功打开路径名，则将其截断为零长度。</span></div></div><div id="vc6YV1PGYJsmtCY5iSjWns" class="wolai-block wolai-text"><div><span class="inline-wrap">、</span><span class="inline-wrap"><b>使用方式：</b></span></div></div><div id="2hC5D5Q682JJWuSZj9iZnH" class="wolai-block wolai-text"><div><span class="inline-wrap">首先需要在需要跟踪的程序中包含头文件 </span><span class="inline-wrap"><code>mcheck.h</code></span><span class="inline-wrap">，并在 </span><span class="inline-wrap"><code>main()</code></span><span class="inline-wrap"> 函数的最开始调用 </span><span class="inline-wrap"><code>mtrace()</code></span><span class="inline-wrap"> 函数。然后，我们需要用 </span><span class="inline-wrap"><code>mtrace()</code></span><span class="inline-wrap"> 和 </span><span class="inline-wrap"><code>muntrace()</code></span><span class="inline-wrap"> 这一对函数将我们关心的代码段括起来。</span><span class="inline-wrap"><a href="https://en.wikipedia.org/wiki/Mtrace"><span>mtrace - 维基百科 (wikipedia.org)</span></a></span></div></div><div id="nGHp4XaoUJk6B2eW7NYztu" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>原理：</b></span></div></div><div id="ioWfnrjiJLB2CVS3ZVdy7X" class="wolai-block wolai-text"><div><span class="inline-wrap">mtrace 工具的主要思路是在我们调用内存分配和释放的函数中装载 “钩子（hook）” 函数，通过 “钩子（hook）” 函数打印的日志来帮助我们分析对内存的使用是否存在问题。</span></div></div><h2 id="jLghtcN9QdYvp4kqwoAJ7T" class="wolai-block"><span class="inline-wrap">其他</span></h2><div id="9YVKipZyQVjriCHv3z2hcg" class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://cloud.tencent.com/developer/article/2231225"><span>AddressSanitizer</span></a></span><span class="inline-wrap">：一个支持多种平台的内存错误检测工具，能够检测出越界访问、使用后释放、初始化错误等问题。</span></div></div><div id="mihH2ffUVysNcPnjZvbgF4" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>LeakTracer</b></span><span class="inline-wrap"> 可以在 Linux、Solaris 和 HP-UX 下跟踪和分析 C++ 程序中的内存泄漏</span><span class="inline-wrap"><a href="https://bing.com/search?q=linux内存泄漏检测工具"><span>1</span></a></span><span class="inline-wrap">。</span></div></div><div id="eMZv9EzMdpP4EBLWmVvaRd" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>Electric Fence</b></span><span class="inline-wrap"> 是由 Bruce Perens 编写的 malloc() 调试库，它可以帮助您检测两种常见的编程错误：软件超出 malloc() 内存分配的边界，以及软件触摸已被 free() 释放的内存分配<span class="jill"></span>⁴。与其他 malloc() 调试器不同，Electric Fence 会检测读取访问和写入访问，并精确定位发生错误的指令。</span></div></div><h1 id="4qW2AWD4YwdKPwDvnZhA4Y" class="wolai-block"><span class="inline-wrap">macOS</span></h1><div id="r4jT41ZfyqQV2YVP97nPmj" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>leaks</b></span><span class="inline-wrap">是<span class="jill"></span>macOS<span class="jill"></span>自带的一个命令行工具，它可以帮助您检测<span class="jill"></span>C/C++<span class="jill"></span>程序中的内存泄漏。</span><span class="inline-wrap"><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingLeaks.html"><span>苹果开发者网站</span></a></span><span class="inline-wrap">上有一些关于如何使用此工具来快速找到内存泄漏的提示，例如在单元测试期间运行<span class="jill"></span>leaks。您可以在命令行中使用此工具来跟踪内存泄漏。</span></div></div><div id="c9AfRHmAseKCJnbB3X1e5V" class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://stackoverflow.com/questions/53456304/mac-os-leaks-sanitizer"><span>Leaks Sanitizer</span></a></span><span class="inline-wrap">是在<span class="jill"></span>Xcode<span class="jill"></span>中的工具，可以使用来检测内存泄漏。它会运行您的应用程序并显示一个轨迹，向您展示任何泄漏</span></div></div><h1 id="7miG2DH3KRhBvKdWSJ8jYB" class="wolai-block"><span class="inline-wrap">windows</span></h1><h2 id="5kXYkWEGz59m3hLtUxXQaa" class="wolai-block"><span class="inline-wrap">tMemoryMonitor</span></h2><div id="jzVfVjcPhtx134GDgkRgMx" class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://wetest.qq.com/labs/40"><span>tMemoryMonitor</span></a></span><span class="inline-wrap">：一个运行时<span class="jill"></span>C/C++<span class="jill"></span>内存泄漏检测工具，认为在进程退出时没有被释放且没有指针指向的无主内存块即为内存泄漏，并引入垃圾回收机制，在进程退出时检测出堆内存中所有没有被引用的内存单元。</span></div></div><blockquote id="iNgH18g88NTWvzfM3CobDV" class="wolai-block"><span class="inline-wrap">但目前只有<span class="jill"></span>windows<span class="jill"></span>版本，更新时间：2023<span class="jill"></span>年<span class="jill"></span>3<span class="jill"></span>月<span class="jill"></span>6<span class="jill"></span>日</span></blockquote></article><footer></footer></body></html>