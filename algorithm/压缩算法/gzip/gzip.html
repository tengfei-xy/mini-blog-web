<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../../css/wolai.css"/><title>gzip - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body class="full-width small-font less-lead"><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="gzip" class="main-title"></div></div></header><article><details id="q8QbkDXux1rDMoYhGZp8KS" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">算法说明</span></summary><div id="tWxDYbUzZ1rCSC8eLno6VD" class="wolai-block wolai-text"><div><span class="inline-wrap"><a href="https://www.cnblogs.com/en-heng/p/4992916.html"><span>LZ77</span></a></span><span class="inline-wrap">
</span><span class="inline-wrap"><a href="https://blog.csdn.net/weixin_30654583/article/details/95064293"><span>LZ77<span class="jill"></span>简介</span></a></span><span class="inline-wrap">
</span><span class="inline-wrap"><a href="https://www.cnblogs.com/idreamo/p/9249367.html"><span>数据压缩算法---LZ77<span class="jill"></span>算法 的分析与实现 </span></a></span><span class="inline-wrap">
</span><span class="inline-wrap"><a href="https://www.cnblogs.com/idreamo/p/9153691.html"><span>数据压缩的重要组成部分---位操作 </span></a></span><span class="inline-wrap">
</span><span class="inline-wrap"><a href="https://www.cnblogs.com/kuang17/p/7193124.html#:~:text=gzip,%E5%AF%B9%E4%BA%8E%E8%A6%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E9%A6%96%E5%85%88%E4%BD%BF%E7%94%A8LZ77%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8F%98%E7%A7%8D%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9%EF%BC%8C%E5%AF%B9%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E5%86%8D%E4%BD%BF%E7%94%A8Huffman%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%AE%9E%E9%99%85%E4%B8%8Agzip%E6%A0%B9%E6%8D%AE%E6%83%85%E5%86%B5%EF%BC%8C%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81Huffman%E7%BC%96%E7%A0%81%E6%88%96%E8%80%85%E5%8A%A8%E6%80%81Huffman%E7%BC%96%E7%A0%81%EF%BC%8C%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9%E5%9C%A8%E5%AE%9E%E7%8E%B0%E4%B8%AD%E8%AF%B4%E6%98%8E%EF%BC%89%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9%E3%80%82"><span>Huffman</span></a></span><span class="inline-wrap">
</span><span class="inline-wrap"><a href="https://www.rfc-editor.org/rfc/rfc1952"><span>RFC-1952 GZIP 文件格式规范版本</span></a></span></div></div></details><details id="mVdwuWF14FP2pqqXCN6FhD" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">C<span class="jill"></span>实现</span></summary><div id="kiuihakaxV7kdNvcxTfjgk" class="wolai-bookmark wolai-block"><a href="https://blog.csdn.net/hguisu/article/details/7795435">gzip压缩算法_gzip压缩编码-CSDN博客</a><div class="info-box"><div class="text-pane"><div data-title="gzip压缩算法_gzip压缩编码-CSDN博客"></div><div data-desc="文章浏览阅读2.5w次，点赞2次，收藏40次。gzip,zlib,以及图形格式png，使用的是同一个压缩算法deflate。我们通过对gzip源码的分析来对deflate压缩算法做一个详细的说明：第一，gzip压缩算法基本原理的说明。第二，gzip压缩算法实现方法的说明。第三，gzip实现源码级的说明。 1. Gzip压缩算法的原理         gzip 对于要压缩的文件，首先使用LZ77算法"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://g.csdnimg.cn/static/logo/favicon32.ico&quot;)"></div><div data-hostname="blog.csdn.net"></div></div></div><div class="preview-pane"></div></div></div><blockquote id="aRUNvbLBJ2HDbqSoYXF7vJ" class="wolai-block"><span class="inline-wrap"><a href="https://blog.csdn.net/moxiaomomo/article/details/52385837"><span>C<span class="jill"></span>实现<span class="jill"></span>gzip<span class="jill"></span>的压缩与解压</span></a></span></blockquote></details><details id="jdSbAtQHoiBrweh1ig1C1c" class="wolai-block"><summary><div class="marker"></div><span class="inline-wrap">一般实现</span></summary><div id="aaKbpoqf7v6dTUcj4VgvH8" class="wolai-block wolai-text"><div><span class="inline-wrap">gzip（GNU<span class="jill"></span>压缩程序）是一种用于数据压缩和解压缩的文件压缩格式和算法。它使用<span class="jill"></span>DEFLATE<span class="jill"></span>算法（一种基于<span class="jill"></span>LZ77<span class="jill"></span>算法和哈夫曼编码的压缩算法）来压缩文件，并在压缩后的数据上附加一些元数据。</span></div></div><div id="oGjoZL2VnLUA6LWroA1eUN" class="wolai-block wolai-text"><div><span class="inline-wrap">下面是<span class="jill"></span>gzip<span class="jill"></span>的基本压缩过程：</span></div></div><ol class="wolai-block"><li id="eg5U1au3esqmsdzvLJVuqy"><div class="marker"></div><span class="inline-wrap">首先，gzip<span class="jill"></span>将输入文件分成多个固定大小的块。每个块通常为<span class="jill"></span>32KB<span class="jill"></span>到<span class="jill"></span>64KB<span class="jill"></span>的大小。</span></li><li id="7fT3wo7kVbo85KTafw8EXR"><div class="marker"></div><span class="inline-wrap">对于每个块，gzip<span class="jill"></span>使用<span class="jill"></span>LZ77<span class="jill"></span>算法来查找重复的数据模式。LZ77<span class="jill"></span>算法通过滑动窗口来查找已经出现过的数据片段，并用指向该片段的指针来表示。这样可以找到重复的模式，并用更短的表示方式来表示它们。</span></li><li id="muFGCwA35zWxBnA82rhpMU"><div class="marker"></div><span class="inline-wrap">通过<span class="jill"></span>LZ77<span class="jill"></span>算法找到的重复模式被传递给哈夫曼编码器。哈夫曼编码器将频繁出现的模式用较短的编码表示，而不频繁出现的模式用较长的编码表示。这样可以进一步减小数据的大小。</span></li><li id="dge5GKAvychSH6TyJATH5L"><div class="marker"></div><span class="inline-wrap">哈夫曼编码后的数据以及一些附加的元数据（例如文件的名称、时间戳等）被写入输出文件。</span></li></ol><div id="iiGp28jwVWp51mmEEnMSTZ" class="wolai-block wolai-text"><div><span class="inline-wrap">解压缩过程与压缩过程相反：</span></div></div><ol class="wolai-block"><li id="ahyX464Ar1zfh6WcE6qgWk"><div class="marker"></div><span class="inline-wrap">解压缩开始时，gzip<span class="jill"></span>读取压缩文件的元数据，包括块的数量、每个块的大小以及其他必要的信息。</span></li><li id="q7WTZH8rMYnTQT5Esh6bEU"><div class="marker"></div><span class="inline-wrap">针对每个块，gzip<span class="jill"></span>使用相应的<span class="jill"></span>LZ77<span class="jill"></span>和哈夫曼解码器来解码数据并还原为原始的数据块。</span></li><li id="fSPE9a1t6WT8KByZHyyuJA"><div class="marker"></div><span class="inline-wrap">解码的数据块被组合成最终的原始文件。</span></li></ol><div id="qBvbeBexkyaunxpzv5T3Tf" class="wolai-block wolai-text"><div><span class="inline-wrap">总结起来，gzip<span class="jill"></span>使用<span class="jill"></span>DEFLATE<span class="jill"></span>算法将文件分成多个块，然后对每个块进行<span class="jill"></span>LZ77<span class="jill"></span>压缩和哈夫曼编码，最终生成一个包含压缩数据和元数据的<span class="jill"></span>gzip<span class="jill"></span>文件。解压缩时，gzip<span class="jill"></span>读取元数据并逆向操作，将压缩数据解码还原为原始文件。这样可以显著减小文件的大小，节省存储空间和传输带宽。</span></div></div></details><div id="kRXmtKjLQ8coiCQC7PQfqf" class="wolai-block wolai-text"><div><span class="inline-wrap">zip<span class="jill"></span>和<span class="jill"></span>gzip<span class="jill"></span>使用的压缩算法是<span class="jill"></span>Lempel-Ziv 1977 [LZ77]的变体。它在输入数据中查找重复的字符串。 字符串的第二次出现被替换为指向前一个字符串的指针，形式为一对 (distance,length)。 距离限制为 32K 字节，长度限制为 258 字节。 当一个字符串在之前的 32K 字节中没有出现时，它会作为文字字节序列发出。 （在此描述中，&#39;string&#39; 必须被视为任意字节序列，并且不限于可打印字符。）</span></div></div><div id="uzznMHkUTZ4o4tH1rR2W6t" class="wolai-block wolai-text"><div><span class="inline-wrap">文字或匹配长度用一棵哈夫曼树压缩，匹配距离用另一棵树压缩。 树以紧凑的形式存储在每个块的开头。 块可以有任何大小（除了一个块的压缩数据必须适合可用内存）。 当 zip 确定用新树开始另一个块是有用的时，一个块就会终止。 （这有点类似于压缩。）</span></div></div><div id="bbxoAQiV45569soGtWcpVJ" class="wolai-block wolai-text"><div><span class="inline-wrap">使用哈希表找到重复的字符串。 所有长度为 3 的输入字符串都被插入哈希表中。 为接下来的 3 个字节计算哈希索引。 如果该索引的散列链不为空，则将链中的所有字符串与当前输入字符串进行比较，并选择最长的匹配项。</span></div></div><div id="x1Uf9MJpyjE4UoEc8jyxcd" class="wolai-block wolai-text"><div><span class="inline-wrap">从最近的字符串开始搜索散列链，以支持小距离，从而利用霍夫曼编码。 散列链是单链接的。 哈希链中没有删除，算法只是丢弃太旧的匹配项。</span></div></div><div id="7UEunyr6vhzcoV1hzWh5j1" class="wolai-block wolai-text"><div><span class="inline-wrap">为了避免最坏的情况，很长的散列链被任意截断到一定长度，由运行时选项（zip -1 到 -9）决定。 所以 zip 并不总能找到可能的最长匹配，但通常会找到足够长的匹配。</span></div></div><div id="8WvioVCUSd9UMiCteHoYtA" class="wolai-block wolai-text"><div><span class="inline-wrap">zip 还延迟了具有惰性评估机制的匹配项的选择。 找到长度为 N 的匹配项后，zip 会在下一个输入字节处搜索更长的匹配项。 如果找到更长的匹配项，则先前的匹配项被截断为一个长度（从而产生单个文字字节），然后发出更长的匹配项。 否则，保留原始匹配，仅在 N 步后尝试下一个匹配搜索。</span></div></div><div id="vnDopxveoAiCJtucb6vxam" class="wolai-block wolai-text"><div><span class="inline-wrap">惰性匹配评估也受制于运行时参数。 如果当前匹配足够长，zip 会减少对更长匹配的搜索，从而加快整个过程。 如果压缩率比速度更重要，zip 会尝试进行完整的第二次搜索，即使第一次匹配已经足够长。</span></div></div><div id="mLMyzM3Mdf3Vkgtm9rxDt5" class="wolai-block wolai-text"><div><span class="inline-wrap">对于最快的压缩模式（速度选项 -1 到 -3）不执行惰性匹配评估。 对于这些快速模式，仅当未找到匹配项或匹配项不太长时，才将新字符串插入到哈希表中。 这降低了压缩率，但节省了时间，因为插入和搜索都更少了。</span></div></div></article><footer></footer></body></html>